C51 COMPILER V9.00   ISR                                                                   07/03/2017 18:41:18 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE ISR
OBJECT MODULE PLACED IN .\Obj\isr.obj
COMPILER INVOKED BY: C:\Keil4\C51\BIN\C51.EXE ..\Code\isr.c OPTIMIZE(9,SPEED) BROWSE INCDIR(..\Code\INC;..\Code\DRIVER\I
                    -NC;..\Code\DRIVER\MST9U\INC;..\Code\DRIVER\MST9U3\INC) DEFINE(ModelName=MST9U3_DEMO,CHIP_ID=MST9U3) DEBUG OBJECTEXTEND P
                    -RINT(.\List\isr.lst) OBJECT(.\Obj\isr.obj)

line level    source

   1          #include "types.h"
   2          #include "board.h"
   3          #include "global.h"
   4          #include "debug.h"
   5          #include "debugDef.h"
   6          #include "Common.h"
   7          #include "ms_reg.h"
   8          #include "Ms_rwreg.h"
   9          #include "gpio_def.h"
  10          #include "mcu.h"
  11          #include "drvPM.h"
  12          #include "halRWreg.h"
  13          #include "drvMBX.h"
  14          #include "Buzzer.h"
  15          //#include "halRwreg.h"
  16          
  17          
  18          
  19          
  20          //#define ReSyncTick          255//54 // 0.2 Second for resynchorize dubug process
  21          #if EXT_TIMER0_1MS
              #define EnableExt0Interrupt     0
              #define EnableExt1Interrupt     1
              #define EnableTime0Interrupt        0
              #else
  26          #define EnableExt0Interrupt     1
  27          #define EnableTime0Interrupt        (!EXT_TIMER0_1MS)
  28          #endif
  29          
  30          #if (UseINT || ENABLE_SW_DOUBLE_BUFFER)
              #define EnableExt1Interrupt     1
              #define EnableSerialPortInterrupt   1 // 0
              #else
  34          #define EnableExt1Interrupt     1 //0
  35          #define EnableSerialPortInterrupt   1
  36          #endif
  37          
  38          //#define EnableTime1Interrupt        1
  39          //#define EnableTime2Interrupt        0
  40          
  41          #if EXT_TIMER0_1MS
              static void ms1MsHandler(void); // Jonson 20110713
              #endif
  44          #if ENABLE_SW_DOUBLE_BUFFER
              extern XDATA StuSWDBCtrl SWDBCtrl;
              
              void IsrML(void)
              {
                  SWDBCtrl.ucSWDB_Counter = 0;
                  SWDBCtrl.ucSWDB_OnFire = 0;
                  SWDBCtrl.ucSWDB_Num = 1;
                  msRegs[REG_003C25] &=0x3F;
              }
C51 COMPILER V9.00   ISR                                                                   07/03/2017 18:41:18 PAGE 2   

              #endif
  55          
  56          #if(IR_REMOTE_SEL != NO_REMOTE)
              extern void irInterruptProcess(void);
              #endif
  59          
  60          #if UseINT
              void MuteVideoAndAudio(void)
              {
              
              #if ENABLE_LED_CONTROLLER
                  MEM_MSWRITE_BYTE(REG_0A80,0x00);
                  MEM_MSWRITE_BYTE(REG_0A81,0x00);
              #else
                  hw_ClrBlacklit();
              #endif
              }
              
              void IsrModeChangeCheck(void)
              {
                  MEM_SCWRITE_BYTE(0, 0); //bk0
                  if (INT_STATUS_A_ISR(BIT4|BIT5|BIT6|BIT7) || INT_STATUS_B_ISR(BIT2))//((MEM_SCREAD_BYTE(SC0_CC)&(BIT4|
             -BIT5|BIT6|BIT7)) || (MEM_SCREAD_BYTE(SC0_CD)&BIT2))
                  {
                      INT_SCALER_A_ISR(0);//MEM_SCWRITE_BYTE(SC0_CE, 0); //disable INT
                      INT_SCALER_B_ISR(0);//MEM_SCWRITE_BYTE(SC0_CF, 0); //disable INT
                      INT_STATUS_CLEAR_ISR();
              //        if (!SyncLossState())
                      {
                          MuteVideoAndAudio();
                      }
                  }
              
              }
              #endif
  88          
  89          #if EnableExt0Interrupt
  90          void EXT0Interrupt( void )interrupt 0
  91          {
  92   1          BYTE ucStatus;
  93   1          BYTE ucP2BK;
  94   1      #if ENABLE_MBX
                  BYTE u8MailStatus;
              #endif
  97   1          ucP2BK = P2;
  98   1      
  99   1          ucStatus = MEM_MSREAD_BYTE_EXT0(REG_002B18);
 100   1          MEM_MSWRITE_BYTE(REG_002B18,ucStatus);
 101   1      
 102   1        #if 0//EXT_TIMER0_1MS
                  if( ucStatus & _BIT0 )
                      ms1MsHandler();
                #endif
 106   1      
 107   1      #if ENABLE_R2_INT_M51_Test
                      u8nonPMFIQStatus=0x00;
                      if (u8HostS2D<=0x02)
                          u8nonPMFIQStatus = MEM_MSREAD_BYTE_EXT0(REG_10191E);
                      else if (u8HostS2D>=0x03 && u8HostS2D<=0x08 )
                          u8nonPMFIQStatus = MEM_MSREAD_BYTE_EXT0(REG_10191D);
                      else if (u8HostS2D>=0x09 && u8HostS2D<=11 )
                          u8nonPMFIQStatus = MEM_MSREAD_BYTE_EXT0(REG_10191C);
C51 COMPILER V9.00   ISR                                                                   07/03/2017 18:41:18 PAGE 3   

                      if(u8nonPMFIQStatus)
                      {
                              if(bR2_int_M51_flag == 0)
                                      bR2_int_M51_flag = 1;
                      }
                      MEM_MSWRITE_BYTE(REG_10190C,0xFF);
                      MEM_MSWRITE_BYTE(REG_10190D,0xFF);
                      MEM_MSWRITE_BYTE(REG_10190E,0xFF);
              
                      MEM_MSWRITE_BYTE(REG_10054C,0x00);
                      MEM_MSWRITE_BYTE(REG_100548,0x00);
                      MEM_MSWRITE_BYTE(REG_100544,0x00);
                      MEM_MSWRITE_BYTE(REG_100540,0x00);
              
              #endif
 130   1      #if ENABLE_MBX
                  u8MailStatus = MEM_MSREAD_BYTE_EXT0(REG_10191D);
                  MEM_MSWRITE_BIT_ISR(_EXT0, REG_10191D, 1, BIT2);
                  if(u8MailStatus & BIT2)
                  {
                      if(bMailNT == 0)
                          bMailNT = 1;
                  }
              #endif
 139   1      
 140   1          P2 = ucP2BK;
 141   1      
 142   1          IE0 = 0;
 143   1      }
 144          #endif
 145          extern BYTE xdata g_u8KeyDebounceCounter;
 146          extern WORD xdata g_u32KeyCounter;
 147          
 148          #if EnableTime0Interrupt
 149          //extern WORD ms_Counter;
 150          //extern BYTE ReSyncCounter;
 151          //extern BYTE Second;
 152          //extern BYTE xdata OsdCounter;
 153          //extern BYTE xdata PowerDownCounter;
 154          extern XDATA ePM_WakeupStatus ucWakeupStatus;
 155          
 156          void Time0Interrupt( void )interrupt 1
 157          #else
              static void ms1MsHandler(void)
              #endif
 160          {
 161   1          TH0 = g_ucTimer0_TH0;
 162   1          TL0 = g_ucTimer0_TL0;
 163   1      
 164   1          ms_Counter--;
 165   1      
 166   1      #if ENABLE_DEBUG
                  if( ReSyncCounter )
                  {
                      ReSyncCounter--;
                      if( ReSyncCounter == 0)
                      {
                          //Clr_RxBusyFlag();
                          SIORxIndex = 0;
                      }
                  }
              #endif
C51 COMPILER V9.00   ISR                                                                   07/03/2017 18:41:18 PAGE 4   

 177   1      #if UART1
                  if( ReSyncCounter1)
                  {
                      ReSyncCounter1--;
                      if( ReSyncCounter1 == 0 )
                      {
                          SIORxIndex1 = 0;
                      }
                  }
              #endif
 187   1      #if ENABLE_BUZZER
                  if(g_ucPWMTimer)
                  {
                      g_ucPWMTimer--;
                      if(g_ucPWMTimer==0)
                          bBuzzer = 1;
                  }
              #endif
 195   1      
 196   1          if( bDelayFlag )
 197   1              if( --DelayCounter == 0 )
 198   1                  bDelayFlag = 0;
 199   1      
 200   1          if(TimeOutCounter)
 201   1              TimeOutCounter--;
 202   1      
 203   1          if(ModeDetectCounter)
 204   1               ModeDetectCounter--;
 205   1      
 206   1      
 207   1          if(g_u8KeyDebounceCounter)
 208   1              g_u8KeyDebounceCounter--;
 209   1          if(g_u32KeyCounter)
 210   1              g_u32KeyCounter--;
 211   1      
 212   1          if(g_u32MailCounter)
 213   1              g_u32MailCounter++;
 214   1      
 215   1          if(!g_bMcuPMClock) // system runs at normal speed
 216   1          {
 217   2          }
 218   1      
 219   1          if( ms_Counter == 0 )        //
 220   1          {
 221   2              Set_SecondFlag();
 222   2              ms_Counter = SystemTick;
 223   2          }
 224   1      
 225   1          if(( ms_Counter % 10 ) == 0 )
 226   1          {
 227   2              Set_ms10Flag();
 228   2              #if (IR_REMOTE_SEL!=NO_REMOTE)
                        if( IRkeyDelayCounter)
                          IRkeyDelayCounter--;
                      #endif
 232   2      
 233   2              if(( ms_Counter % 50 ) == 0 )
 234   2              {
 235   3                  Set_ms50Flag();
 236   3      
 237   3                  if(( ms_Counter % 500 ) == 0 )
 238   3                  {
C51 COMPILER V9.00   ISR                                                                   07/03/2017 18:41:18 PAGE 5   

 239   4                      Set_ms500Flag();
 240   4                  }
 241   3              }
 242   2      
 243   2              if(( ms_Counter % 200 ) == 0 )
 244   2              {
 245   3               #if _NEW_SOG_WAKEUP_DET_
                              if(ucWakeupStatus == ePMSTS_NON)
                                     NEW_SOG_WAKEUP_FLUSH_ISR(_TIME0);
                      #endif
 249   3              }
 250   2          }
 251   1      
 252   1          if(TF0)
 253   1          {
 254   2              TH0 = g_ucTimer0_TH0;
 255   2              TL0 = g_ucTimer0_TL0;
 256   2          }
 257   1      
 258   1          TF0 = 0; // timer 1 flag
 259   1      
 260   1      }
 261          //#endif
 262          #if EnableExt1Interrupt
 263          void EXT1Interrupt( void )interrupt 2
 264          {
 265   1          BYTE ucStatus_002B38, ucStatus_002B18;
 266   1          BYTE ucP2BK;
 267   1      
 268   1          ucP2BK = P2;
 269   1      
 270   1          //MEM_MSWRITE_BYTE(REG_002B00,1);
 271   1          ucStatus_002B18 = MEM_MSREAD_BYTE_EXT1(REG_002B18);
 272   1          ucStatus_002B38 = MEM_MSREAD_BYTE_EXT1(REG_002B38);
 273   1      
 274   1          //  EX1=0;
 275   1      
 276   1      // BYTE ucBank = MEM_SCREAD_BYTE(0x00);       //110926 Rick add to store the current bank - Verify A036, A
             -039
 277   1      
 278   1      if( _BIT1 & ucStatus_002B38) // PM_IRQ
 279   1      {
 280   2      #if ENABLE_WATCH_DOG_INT
                  if( _BIT1 & ucStatus_002B18 ) // WDT int
                  {
                          u8WDT_Status=0x33;
                  }
              #endif
 286   2      #if EXT_TIMER0_1MS
                  if( _BIT0 & ucStatus_002B18)    //Ext Timer
                  {
                      ms1MsHandler();
                  }
              #endif
 292   2      #if  ENABLE_SW_DOUBLE_BUFFER
                  if(_bit4_(ucStatus_002B18))
                      IsrML();
              #endif
 296   2      }
 297   1      #if(IR_REMOTE_SEL != NO_REMOTE)
                  if(_bit3_(ucStatus_002B18))
                  {
C51 COMPILER V9.00   ISR                                                                   07/03/2017 18:41:18 PAGE 6   

                      irInterruptProcess();
                  }
              #endif
 303   1      
 304   1      #if UseINT
                  if(INT_STATUS_DISP_ISR())
                  {
                      IsrModeChangeCheck();
                  }
              #endif
 310   1          MEM_MSWRITE_BYTE(REG_002B18,ucStatus_002B18);
 311   1         // MEM_MSWRITE_BYTE(REG_002B38,ucStatus_002B38);     Do not clear IRQ status
 312   1      
 313   1      //    MEM_SCWRITE_BYTE(0x00, ucBank);
 314   1          IE1 = 0;
 315   1          //  EX1=1;
 316   1          P2 = ucP2BK;
 317   1      }
 318          
 319          #endif
 320          
 321          #if EnableTime1Interrupt
 322          void Time1Interrupt( void )interrupt 3
 323          {
 324   1          {
 325   2              TH1=g_ucTimer0_TH0;
 326   2              TL1=g_ucTimer0_TL0; // timer 1 counter
 327   2          }
 328   1      
 329   1      
 330   1          g_u16MsCounter1--;
 331   1          if (g_u16MsCounter1==0) //
 332   1          {
 333   2              bSecondTimer1 = TRUE;
 334   2              g_u16MsCounter1=1000;
 335   2          }
 336   1      }
 337          #endif
 338          #if EnableSerialPortInterrupt
 339          void SerialPortInterrupt( void )interrupt 4
 340          {
 341   1          BYTE sioData;
 342   1      
 343   1          if( RI )
 344   1          {
 345   2              RI = 0;
 346   2              sioData = SBUF;
 347   2              if( SIORxIndex < _UART_BUFFER_LENGTH_ )
 348   2              {
 349   3                  SIORxBuffer[SIORxIndex++] = sioData;
 350   3                  if(SIORxIndex < UART_CMD_LENGTH)
 351   3                      ReSyncCounter = ReSyncTick;
 352   3                  else
 353   3                      ReSyncCounter = 0xFF;
 354   3              }
 355   2          }
 356   1          if( TI )
 357   1          {
 358   2              TI = 0;
 359   2              TI0_FLAG = 1;
 360   2          }
 361   1      }
C51 COMPILER V9.00   ISR                                                                   07/03/2017 18:41:18 PAGE 7   

 362          #endif
 363          #if EnableTime2Interrupt
              void Time2Interrupt( void )interrupt 5
              {
                  TF2 = 0;
              }
              #endif
 369          #if UART1
              void SerialPort1Interrupt (void)interrupt 16
              {
                  BYTE sioData;
              
                  if(S1CON & RI1)
                  {
                      S1CON &= ~RI1;
                      sioData = S1BUF;
                      if( SIORxIndex1 < _UART_BUFFER_LENGTH_ )
                      {
                          //ReSyncCounter = ReSyncTick;
                          SIORxBuffer1[SIORxIndex1++] = sioData;
                          if(SIORxIndex1 < UART_CMD_LENGTH)
                              ReSyncCounter1 = ReSyncTick;
                          else
                              ReSyncCounter1 = 0xFF;
              
                      }
                  }
              
                  if(S1CON & TI1)
                  {
                      S1CON &= ~TI1;
                      TI1_FLAG = 1;
                  }
              }
              #endif
 397          
 398          
 399          void EXT3Interrupt( void )interrupt 10
 400          {
 401   1      
 402   1      }
 403          
 404          void EXT2Interrupt( void )interrupt 9
 405          {
 406   1      
 407   1      }
 408          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    558    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       4
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
