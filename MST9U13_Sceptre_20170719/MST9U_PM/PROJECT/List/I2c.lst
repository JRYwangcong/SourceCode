C51 COMPILER V9.00   I2C                                                                   07/03/2017 18:41:20 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE I2C
OBJECT MODULE PLACED IN .\Obj\I2c.obj
COMPILER INVOKED BY: C:\Keil4\C51\BIN\C51.EXE ..\Code\I2c.c OPTIMIZE(9,SPEED) BROWSE INCDIR(..\Code\INC;..\Code\DRIVER\I
                    -NC;..\Code\DRIVER\MST9U\INC;..\Code\DRIVER\MST9U3\INC) DEFINE(ModelName=MST9U3_DEMO,CHIP_ID=MST9U3) DEBUG OBJECTEXTEND P
                    -RINT(.\List\I2c.lst) OBJECT(.\Obj\I2c.obj)

line level    source

   1          #include "Types.h"
   2          #include "Board.h"
   3          #include "Common.h"
   4          #include "Global.h"
   5          #include "misc.h"
   6          #include "GPIO_DEF.h"
   7          #include "ms_reg.h"
   8          #include "Ms_rwreg.h"
   9          #include "i2cdef.h"
  10          #if (USE_SW_I2C == 0)
              #include "hwi2c.h"
              #endif
  13          #include "i2c.h"
  14          
  15          #define i2cSlaveAddr(deviceID, addr)    (deviceID|((addr>>8)<<1))
  16          #define i2cWordAddr(addr)       (addr&0xFF)
  17          BYTE ucADDR_HI_BYTE;
  18          
  19          #if !USEFLASH || (defined(UseVGACableReadWriteAllPortsEDID)&&!defined(UseInternalDDCRam))
  20          #if (USE_SW_I2C == 1)
  21          //====================================
  22          // Setup i2c Start condition
  23          Bool i2c_Start( void )
  24          {
  25   1          Set_i2c_SDA();
  26   1          Set_i2c_SCL();
  27   1          Delay4us();
  28   1          if( i2c_SDALo() || i2c_SCLLo() )
  29   1              return FALSE;
  30   1          Clr_i2c_SDA();
  31   1          Delay4us();
  32   1          Clr_i2c_SCL();
  33   1          Delay4us();
  34   1          return TRUE;
  35   1      }
  36          //=============================================
  37          // Setup i2c Stop condition
  38          void i2c_Stop( void )
  39          {
  40   1          // SCL=L, SDA=L, Stop condition.
  41   1          Clr_i2c_SCL();
  42   1          Clr_i2c_SDA();
  43   1          Delay4us();
  44   1          Set_i2c_SCL();
  45   1          Delay4us();
  46   1          Set_i2c_SDA();
  47   1          Delay4us();
  48   1      }
  49          //============================================
  50          Bool Wait_i2C_Ack( void )
  51          {
  52   1          BYTE i;
  53   1          for( i = 0; i < 5; i++ )
C51 COMPILER V9.00   I2C                                                                   07/03/2017 18:41:20 PAGE 2   

  54   1          {           
  55   2              Delay4us();
  56   2              if( i2c_SDALo() )
  57   2                  return TRUE;
  58   2          }
  59   1      
  60   1          if( i2c_SDALo() )
  61   1              return TRUE;
  62   1          else
  63   1              return FALSE;
  64   1      
  65   1      }
  66          //============================================
  67          Bool i2c_SendByte( BYTE value )
  68          {
  69   1          BYTE i;
  70   1          Bool result;
  71   1      
  72   1          for( i = 0; i < 8; i++ ) // Send data via i2c pin
  73   1          {
  74   2              if( value & BIT7 )
  75   2                  Set_i2c_SDA();
  76   2              else
  77   2                  Clr_i2c_SDA();
  78   2              Delay4us();
  79   2              Set_i2c_SCL();
  80   2              Delay4us();
  81   2              value <<= 1;
  82   2              Clr_i2c_SCL();
  83   2          }
  84   1          Set_i2c_SDA();
  85   1          result = Wait_i2C_Ack();
  86   1          Set_i2c_SCL();
  87   1          Delay4us();
  88   1          Clr_i2c_SCL();
  89   1          Delay4us();
  90   1          Clr_i2c_SDA();
  91   1      
  92   1          return result;
  93   1      }
  94          
  95          //============================================
  96          BYTE i2c_ReceiveByte( const Bool ack )
  97          {
  98   1          BYTE i;
  99   1          BYTE value = 0;
 100   1      
 101   1          for( i = 0; i < 8; i++ )
 102   1          {
 103   2              value <<= 1;
 104   2              Set_i2c_SDA();
 105   2              Delay4us();
 106   2              Set_i2c_SCL();
 107   2              Delay4us();
 108   2              if( i2c_SDAHi() )
 109   2                  value |= BIT0;
 110   2              Clr_i2c_SCL();
 111   2          }
 112   1          if( ack )
 113   1          {
 114   2              Clr_i2c_SDA();
 115   2          }
C51 COMPILER V9.00   I2C                                                                   07/03/2017 18:41:20 PAGE 3   

 116   1          else
 117   1          {
 118   2              Set_i2c_SDA();
 119   2          }
 120   1          Delay4us();
 121   1          Set_i2c_SCL();
 122   1          Delay4us();
 123   1          Clr_i2c_SCL();
 124   1      
 125   1          return value;
 126   1      }
 127          
 128          void i2c_Start1(void)
 129          {
 130   1          Set_i2c_SDA();
 131   1          Delay4us();
 132   1          Set_i2c_SCL();
 133   1          Delay4us();
 134   1          Clr_i2c_SDA();
 135   1          Delay4us();
 136   1          Clr_i2c_SCL();
 137   1      }
 138          void i2C_Intial(void)
 139          {
 140   1          BYTE i, j;
 141   1      
 142   1          for(i=0 ;i < 20; i++)       // Generate SCL signals to reset EEPROM.
 143   1          {
 144   2              Set_i2c_SCL();
 145   2              Delay4us();
 146   2              Clr_i2c_SCL();
 147   2              Delay4us();
 148   2          }
 149   1      
 150   1          j = 20;
 151   1      
 152   1          while( j-- )        // Male EEPROM to Release I2C bus.
 153   1          {
 154   2              for(i=0 ;i < 9; i++)    // 9 STARTs
 155   2              {
 156   3                  i2c_Start1();
 157   3              }
 158   2              i2c_Stop();
 159   2              ForceDelay1ms(10);
 160   2      
 161   2              if(i2c_SDAHi())
 162   2                  break;
 163   2          }
 164   1      
 165   1      }
 166          
 167          #endif
 168          
 169          
 170          Bool i2c_BurstWrite( BYTE count, BYTE *buffer )
 171          {
 172   1          while( count-- )
 173   1          {
 174   2              if( i2c_SendByte( *( buffer++ ) ) == FALSE )
 175   2                  return FALSE;
 176   2          }
 177   1          return TRUE;
C51 COMPILER V9.00   I2C                                                                   07/03/2017 18:41:20 PAGE 4   

 178   1      }
 179          Bool i2c_BurstRead( BYTE count, BYTE * buffer )
 180          {
 181   1          BYTE i;
 182   1      
 183   1          for( i = 0; i < count - 1; i++ )
 184   1              *( buffer + i ) = i2c_ReceiveByte( 1 );
 185   1          *( buffer + i ) = i2c_ReceiveByte( 0 );
 186   1          i2c_Stop();
 187   1          return TRUE;
 188   1      }
 189          
 190          Bool i2c_MasterStart( I2C_Direction direct, BYTE addr )
 191          {
 192   1          #define NVRAM_DEVICE    0xA0
 193   1      
 194   1          BYTE u8Retry=5;
 195   1          //BYTE u8NvRamID=NVRAM_DEVICE;
 196   1          if (direct==I2C_READ) // Set I2C direction bit.
 197   1          {
 198   2              addr=NVRAM_DEVICE;// get 0xA0
 199   2              addr|=BIT0;
 200   2          }
 201   1          else
 202   1              addr&=~BIT0;
 203   1      
 204   1          while (u8Retry--)
 205   1          {
 206   2              if (i2c_Start()==FALSE)
 207   2              {
 208   3                  Delay1ms(1); //tony 24/11/03
 209   3                  continue;
 210   3              }
 211   2              if(direct==I2C_READ)
 212   2              {
 213   3                  if (i2c_SendByte(addr)==TRUE) // send address success
 214   3                      return TRUE;
 215   3              }
 216   2              else
 217   2              {
 218   3                  if (i2c_SendByte(NVRAM_DEVICE)==TRUE) // send address success
 219   3                  {
 220   4      
 221   4                      if (i2c_SendByte(ucADDR_HI_BYTE)==TRUE) // send address success
 222   4                          return TRUE;
 223   4                  }
 224   3              }
 225   2              i2c_Stop();
 226   2              Delay1ms(1);
 227   2          }
 228   1          return FALSE;
 229   1      }
 230          
 231          #if (EEPROM>=EEPROM_24C32)
 232          #define I2C_SLAVE_ADDR(deviceID, addr)   i2cSlaveAddr(deviceID, addr)
 233          #define I2C_WORD_ADDR(addr)              i2cWordAddr(addr)
 234          
 235          
 236          static void ForceDelayNVRAM(WORD u16Nums) //
 237          {
 238   1          WORD u16Count;
 239   1      
C51 COMPILER V9.00   I2C                                                                   07/03/2017 18:41:20 PAGE 5   

 240   1          if (u16Nums>0)
 241   1          {
 242   2              while (u16Nums--)
 243   2              {
 244   3      
 245   3                u16Count=875;
 246   3                while (u16Count--)
 247   3                {
 248   4                  _nop_();
 249   4                }
 250   3              }
 251   2          }
 252   1      }
 253          void i2c_WriteTBL(BYTE u8DeviceID, WORD u16Addr, BYTE *pu8Buffer, WORD u16Count)
 254          {
 255   1          BYTE u8SlaveAddr;
 256   1          BYTE u8WordAddr;
 257   1          WORD u16Offset=0, u16PrevOffset=0;
 258   1          BYTE u8TempSize;
 259   1          //Bool succ=TRUE;
 260   1          WORD u16BitCounter;
 261   1          u16BitCounter = (u16Addr&0xFF);
 262   1          ucADDR_HI_BYTE = (u16Addr>>8);
 263   1          while (u16Count)
 264   1          {
 265   2              u16BitCounter+=(u16Offset-u16PrevOffset);
 266   2              u16PrevOffset = u16Offset;
 267   2              if(u16BitCounter > 0x00FF)
 268   2              {
 269   3                  ucADDR_HI_BYTE = ((u16Addr+u16Offset)>>8);
 270   3                  u16BitCounter=0;
 271   3              }
 272   2      
 273   2              u8SlaveAddr = I2C_SLAVE_ADDR(u8DeviceID, (u16Addr+u16Offset));
 274   2              u8WordAddr = I2C_WORD_ADDR((u16Addr+u16Offset));
 275   2              if (i2c_MasterStart(I2C_WRITE, u8SlaveAddr)==FALSE)
 276   2              {
 277   3                break;
 278   3              }
 279   2              if (i2c_BurstWrite(1, &u8WordAddr)==FALSE)
 280   2              {
 281   3                  break;
 282   3              }
 283   2              u8TempSize=0x10-(u8WordAddr&0xF);
 284   2              if (u16Count>u8TempSize)
 285   2              {
 286   3                  if (i2c_BurstWrite(u8TempSize, (BYTE*)(pu8Buffer+u16Offset))==FALSE)
 287   3                      break;
 288   3                  i2c_Stop();
 289   3                  u16Count-=u8TempSize;
 290   3                  u16Offset+=u8TempSize;
 291   3              }
 292   2              else if (u16Count>0x10)
 293   2              {
 294   3                  if (i2c_BurstWrite(0x10, (BYTE*)(pu8Buffer+u16Offset))==FALSE)
 295   3                      break;
 296   3                  i2c_Stop();
 297   3                  u16Count-=0x10;
 298   3                  u16Offset+=0x10;
 299   3              }
 300   2              else
 301   2              {
C51 COMPILER V9.00   I2C                                                                   07/03/2017 18:41:20 PAGE 6   

 302   3                  if (i2c_BurstWrite(u16Count, (BYTE*)(pu8Buffer+u16Offset))==FALSE)
 303   3                      break;
 304   3                  i2c_Stop();
 305   3                  u16Count=0;
 306   3              }
 307   2              ForceDelayNVRAM(15);
 308   2          }
 309   1          i2c_Stop();
 310   1          ForceDelayNVRAM(15);
 311   1      }
 312          
 313          void i2c_ReadTBL(BYTE u8DeviceID, WORD u16Addr, BYTE *pu8Buffer, WORD u16Count)
 314          {
 315   1          WORD u16Retry=10;
 316   1          BYTE u8SlaveAddr;
 317   1          BYTE u8WordAddr;
 318   1      
 319   1          u8SlaveAddr=I2C_SLAVE_ADDR(u8DeviceID, u16Addr);
 320   1          u8WordAddr=I2C_WORD_ADDR(u16Addr);
 321   1      
 322   1        #if(EEPROM>=EEPROM_24C32)
 323   1          ucADDR_HI_BYTE = (u16Addr>>8);
 324   1        #endif
 325   1      
 326   1          while (u16Retry--)
 327   1          {
 328   2              if (i2c_MasterStart(I2C_WRITE, u8SlaveAddr)==FALSE)
 329   2              {
 330   3                  ForceDelayNVRAM(2);
 331   3                  i2c_Stop();
 332   3                  continue;
 333   3              }
 334   2      
 335   2              if (i2c_BurstWrite(1, &u8WordAddr)==FALSE)
 336   2                  continue;
 337   2      
 338   2              if (i2c_MasterStart(I2C_READ, u8SlaveAddr)==FALSE)
 339   2                  continue;
 340   2      
 341   2              if (i2c_BurstRead(u16Count, pu8Buffer)==FALSE)
 342   2                  continue;
 343   2              return;
 344   2          }
 345   1      }
 346          #else
              
              #define PageWriteLength     16
              #define PageWriteDelayTime  10
              void i2c_WriteTBL( BYTE deviceID, WORD addr, BYTE *buffer, BYTE count )
              {
                  BYTE slaveAddr;
                  BYTE wordAddr;
                  BYTE offset = 0;
                  BYTE tempSize;
                  //Bool succ = TRUE;
              
                  while( count )
                  {
                      slaveAddr = i2cSlaveAddr( deviceID, (addr + offset) );
                      wordAddr = i2cWordAddr( (addr + offset) );
                      if( i2c_MasterStart( I2C_WRITE, slaveAddr ) == FALSE )
                          break;
C51 COMPILER V9.00   I2C                                                                   07/03/2017 18:41:20 PAGE 7   

                      if( i2c_BurstWrite( 1, &wordAddr ) == FALSE )
                          break;
                      tempSize = PageWriteLength - ( wordAddr & ( PageWriteLength - 1 ) );
                      if( count > tempSize )
                      {
                          if( i2c_BurstWrite( tempSize, ( BYTE* )( buffer + offset ) ) == FALSE )
                              break;
                          i2c_Stop();
                          count -= tempSize;
                          offset += tempSize;
                      }
                      else if( count > PageWriteLength )
                      {
                          if( i2c_BurstWrite( 0x10, ( BYTE* )( buffer + offset ) ) == FALSE )
                              break;
                          i2c_Stop();
                          count -= PageWriteLength;
                          offset += PageWriteLength;
                      }
                      else
                      {
                          if( i2c_BurstWrite( count, ( BYTE* )( buffer + offset ) ) == FALSE )
                              break;
                          i2c_Stop();
                          count = 0;
                      }
                      ForceDelay1ms( PageWriteDelayTime );
                  }
                  i2c_Stop();
              }
              
              void i2c_ReadTBL( BYTE deviceID, WORD addr, BYTE *buffer, BYTE count )
              {
                  WORD retry = 5;
                  BYTE slaveAddr;
                  BYTE wordAddr;
              
                  slaveAddr = i2cSlaveAddr( deviceID, addr );
                  wordAddr = i2cWordAddr( addr );
                  while( retry-- )
                  {
                      if( i2c_MasterStart( I2C_WRITE, slaveAddr ) == FALSE )
                          continue;
                      if( i2c_BurstWrite( 1, &wordAddr ) == FALSE )
                          continue;
                      if( i2c_MasterStart( I2C_READ, slaveAddr ) == FALSE )
                          continue;
                      if( i2c_BurstRead( count, buffer ) == FALSE )
                          continue;
                      return;
                  }
              }
              #endif
 417          
 418          #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1284    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.00   I2C                                                                   07/03/2017 18:41:20 PAGE 8   

   DATA SIZE        =      1      49
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
