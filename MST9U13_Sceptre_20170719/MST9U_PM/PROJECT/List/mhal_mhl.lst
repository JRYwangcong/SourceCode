C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MHAL_MHL
OBJECT MODULE PLACED IN .\Obj\mhal_mhl.obj
COMPILER INVOKED BY: C:\Keil4\C51\BIN\C51.EXE ..\Code\mhal_mhl.c OPTIMIZE(9,SPEED) BROWSE INCDIR(..\Code\INC;..\Code\DRI
                    -VER\INC;..\Code\DRIVER\MST9U\INC;..\Code\DRIVER\MST9U3\INC) DEFINE(ModelName=MST9U3_DEMO,CHIP_ID=MST9U3) DEBUG OBJECTEXT
                    -END PRINT(.\List\mhal_mhl.lst) OBJECT(.\Obj\mhal_mhl.obj)

line level    source

   1          ///////////////////////////////////////////////////////////////////////////////////////////////////
   2          ///
   3          /// file    mhal_mhl.c
   4          /// @author MStar Semiconductor Inc.
   5          /// @brief  MHL driver Function
   6          ///////////////////////////////////////////////////////////////////////////////////////////////////
   7          
   8          #ifndef _MHAL_MHL_C_
   9          #define _MHAL_MHL_C_
  10          
  11          //-------------------------------------------------------------------------------------------------
  12          //  Include Files
  13          //-------------------------------------------------------------------------------------------------
  14          #include "Global.h"
  15          #include "mapi_mhl.h"
  16          #include "mdrv_mhl.h"
  17          #include "mhal_mhl.h"
  18          #include "Board.h"
  19          
  20          //-------------------------------------------------------------------------------------------------
  21          //  Local Defines
  22          //-------------------------------------------------------------------------------------------------
  23          #define MHL_HAL_DEBUG_MESSAGE           0
  24          
  25          #if(MHL_DEBUG_MESSAGE && MHL_HAL_DEBUG_MESSAGE)
              #define MHL_HAL_DPUTSTR(str)            printMsg(str)
              #define MHL_HAL_DPRINTF(str, x)         printData(str, x)
              #else
  29          #define MHL_HAL_DPUTSTR(str)
  30          #define MHL_HAL_DPRINTF(str, x)
  31          #endif
  32          
  33          //-------------------------------------------------------------------------------------------------
  34          //  Local Structures
  35          //-------------------------------------------------------------------------------------------------
  36          BYTE ucMHLPowerStatus = MHL_POWER_STATUS_NONE;
  37          BYTE ucMHLCableDetect = 0;
  38          BYTE ucECbusMuxSelect = 0;
  39          WORD usECbusMuxSwitchTimer = 0;
  40          
  41          //-------------------------------------------------------------------------------------------------
  42          //  Global Variables
  43          //-------------------------------------------------------------------------------------------------
  44          
  45          //-------------------------------------------------------------------------------------------------
  46          //  Local Functions
  47          //-------------------------------------------------------------------------------------------------
  48          
  49          //**************************************************************************
  50          //  [Function Name]:
  51          //                  _mhal_mhl_EnableCbusInterrupt()
  52          //  [Description]
  53          //                  
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 2   

  54          //  [Arguments]:
  55          //                  
  56          //  [Return]:
  57          //
  58          //**************************************************************************
  59          void _mhal_mhl_EnableCbusInterrupt(Bool bEnableInterrupt)
  60          {
  61   1          msWriteByteMask(REG_002B29, bEnableInterrupt? 0: BIT4, BIT4); // REG_IRQ_BANK_14[12]
  62   1      }
  63          
  64          #if(CHIP_ID == MST9U3)
  65          //**************************************************************************
  66          //  [Function Name]:
  67          //                  _mhal_mhl_GetECbusMux()
  68          //  [Description]
  69          //                  
  70          //  [Arguments]:
  71          //
  72          //  [Return]:
  73          //                  
  74          //**************************************************************************
  75          BYTE _mhal_mhl_GetECbusMux(BYTE ucPortSelect)
  76          {
  77   1          BYTE ucECbusMux = MHL_ECBUS_MUX_SELECT_NONE;
  78   1          
  79   1          switch(ucPortSelect)
  80   1          {
  81   2              case MHL_INPUT_SELECT_PORT0:
  82   2                  
  83   2                  break;
  84   2      
  85   2              case MHL_INPUT_SELECT_PORT1:
  86   2                  
  87   2                  break;
  88   2      
  89   2              case MHL_INPUT_SELECT_PORT2:
  90   2                  ucECbusMux = MHL_ECBUS_MUX_SELECT_PORT2;
  91   2                  break;
  92   2      
  93   2              case MHL_INPUT_SELECT_PORT3:
  94   2                  ucECbusMux = MHL_ECBUS_MUX_SELECT_PORT3;
  95   2                  break;
  96   2      
  97   2              default:
  98   2      
  99   2                  break;
 100   2          };
 101   1      
 102   1          return ucECbusMux;
 103   1      }
 104          
 105          //**************************************************************************
 106          //  [Function Name]:
 107          //                  _mhal_mhl_SetCableDetect()
 108          //  [Description]
 109          //                  
 110          //  [Arguments]:
 111          //
 112          //  [Return]:
 113          //                  
 114          //**************************************************************************
 115          void _mhal_mhl_SetCableDetect(BYTE ucPortSelect, Bool bFlag)
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 3   

 116          {
 117   1          switch(ucPortSelect)
 118   1          {
 119   2              case MHL_INPUT_SELECT_PORT0:
 120   2                  if(bFlag)
 121   2                  {
 122   3                      msWriteByteMask(REG_002F01, MASKBIT(1:0), MASKBIT(1:0)); // REG_PM_MHL_CBUS0_00[9:8], SW c
             -ontrol cable detect
 123   3                  }
 124   2                  else
 125   2                  {
 126   3                      msWriteByteMask(REG_002F01, BIT1, MASKBIT(1:0)); // REG_PM_MHL_CBUS0_00[9:8], SW control c
             -able detect
 127   3                  }
 128   2                  
 129   2                  break;
 130   2      
 131   2              case MHL_INPUT_SELECT_PORT1:
 132   2                  if(bFlag)
 133   2                  {
 134   3                      msWriteByteMask(REG_003101, MASKBIT(1:0), MASKBIT(1:0)); // REG_PM_MHL_CBUS1_00[9:8], SW c
             -ontrol cable detect
 135   3                  }
 136   2                  else
 137   2                  {
 138   3                      msWriteByteMask(REG_003101, BIT1, MASKBIT(1:0)); // REG_PM_MHL_CBUS1_00[9:8], SW control c
             -able detect
 139   3                  }
 140   2                  
 141   2                  break;
 142   2      
 143   2              case MHL_INPUT_SELECT_PORT2:
 144   2              case MHL_INPUT_SELECT_PORT3:
 145   2                  if(_mhal_mhl_GetECbusMux(ucPortSelect) == GET_MHL_ECBUS_MUX_SELECT())
 146   2                  {
 147   3                      if(bFlag)
 148   3                      {
 149   4                          msWriteByteMask(REG_003301, MASKBIT(1:0), MASKBIT(1:0)); // REG_PM_MHL_CBUS2_00[9:8], 
             -SW control cable detect
 150   4                      }
 151   3                      else
 152   3                      {
 153   4                          msWriteByteMask(REG_003301, BIT1, MASKBIT(1:0)); // REG_PM_MHL_CBUS2_00[9:8], SW contr
             -ol cable detect
 154   4                      }
 155   3                  }
 156   2                  
 157   2                  break;
 158   2      
 159   2              default:
 160   2      
 161   2                  break;
 162   2          };
 163   1      }
 164          
 165          //**************************************************************************
 166          //  [Function Name]:
 167          //                  _mhal_mhl_CbusPadEnable()
 168          //  [Description]
 169          //                  
 170          //  [Arguments]:
 171          //
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 4   

 172          //  [Return]:
 173          //                  
 174          //**************************************************************************
 175          void _mhal_mhl_CbusPadEnable(BYTE ucPortSelect, Bool bEnableCbus)
 176          {
 177   1          switch(ucPortSelect)
 178   1          {
 179   2              case MHL_INPUT_SELECT_PORT0:
 180   2                  msWrite2ByteMask(REG_000460, bEnableCbus? BIT3: 0, BIT3); // REG_PAD_TOP_30[3], Cbus port0 ena
             -ble
 181   2                  msWriteByteMask(REG_002F43, bEnableCbus? 0: BIT3, BIT3);//REG_PM_MHL_CBUS0_21[11], GPIO Enable
             - port0
 182   2                  break;
 183   2      
 184   2              case MHL_INPUT_SELECT_PORT1:
 185   2                  msWrite2ByteMask(REG_000460, bEnableCbus? BIT4: 0, BIT4); // REG_PAD_TOP_30[4], Cbus port1 ena
             -ble
 186   2                  msWriteByteMask(REG_003143, bEnableCbus? 0: BIT3, BIT3);//REG_PM_MHL_CBUS1_21[11], GPIO Enable
             - port1
 187   2                  break;
 188   2      
 189   2              case MHL_INPUT_SELECT_PORT2:
 190   2                  msWrite2ByteMask(REG_000460, bEnableCbus? BIT1: 0, BIT1); // REG_PAD_TOP_30[1], Cbus port2 ena
             -ble
 191   2                  msWriteByteMask(REG_003343, bEnableCbus? 0: BIT3, BIT3);//REG_PM_MHL_CBUS2_21[11], GPIO Enable
             - port2
 192   2                  break;
 193   2      
 194   2              case MHL_INPUT_SELECT_PORT3:
 195   2                  msWrite2ByteMask(REG_000460, bEnableCbus? BIT2: 0, BIT2); // REG_PAD_TOP_30[2], Cbus port3 ena
             -ble
 196   2                  msWriteByteMask(REG_003543, bEnableCbus? 0: BIT3, BIT3);//REG_PM_MHL_CBUS3_21[11], GPIO Enable
             - port3
 197   2                  break;
 198   2      
 199   2              default:
 200   2      
 201   2                  break;
 202   2          };
 203   1      }
 204          
 205          //**************************************************************************
 206          //  [Function Name]:
 207          //                  _mhal_mhl_SetVbusCharge()
 208          //  [Description]
 209          //                  
 210          //  [Arguments]:
 211          //
 212          //  [Return]:
 213          //                  
 214          //**************************************************************************
 215          void _mhal_mhl_SetVbusCharge(BYTE ucPortSelect, Bool bFlag)
 216          {
 217   1          switch(ucPortSelect)
 218   1          {
 219   2              case MHL_INPUT_SELECT_PORT0:
 220   2                  if(bFlag)
 221   2                  {
 222   3                      SET_MHL_VBUS_CHARGE_PORT0();
 223   3                  }
 224   2                  else
 225   2                  {
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 5   

 226   3                      CLR_MHL_VBUS_CHARGE_PORT0();
 227   3                  }
 228   2                  
 229   2                  break;
 230   2      
 231   2              case MHL_INPUT_SELECT_PORT1:
 232   2                  if(bFlag)
 233   2                  {
 234   3                      SET_MHL_VBUS_CHARGE_PORT1();
 235   3                  }
 236   2                  else
 237   2                  {
 238   3                      CLR_MHL_VBUS_CHARGE_PORT1();
 239   3                  }
 240   2                  
 241   2                  break;
 242   2      
 243   2              case MHL_INPUT_SELECT_PORT2:
 244   2                  if(bFlag)
 245   2                  {
 246   3                      SET_MHL_VBUS_CHARGE_PORT2();
 247   3                  }
 248   2                  else
 249   2                  {
 250   3                      CLR_MHL_VBUS_CHARGE_PORT2();
 251   3                  }
 252   2                  
 253   2                  break;
 254   2      
 255   2              case MHL_INPUT_SELECT_PORT3:
 256   2                  if(bFlag)
 257   2                  {
 258   3                      SET_MHL_VBUS_CHARGE_PORT3();
 259   3                  }
 260   2                  else
 261   2                  {
 262   3                      CLR_MHL_VBUS_CHARGE_PORT3();
 263   3                  }
 264   2                  
 265   2                  break;
 266   2      
 267   2              default:
 268   2      
 269   2                  break;
 270   2          };
 271   1      }
 272          
 273          //**************************************************************************
 274          //  [Function Name]:
 275          //                  _mhal_mhl_OpenCommonModeResistor()
 276          //  [Description]
 277          //                  
 278          //  [Arguments]:
 279          //
 280          //  [Return]:
 281          //                  
 282          //**************************************************************************
 283          void _mhal_mhl_OpenCommonModeResistor(BYTE ucPortSelect, Bool bFlag)
 284          {
 285   1          switch(ucPortSelect)
 286   1          {
 287   2              case MHL_INPUT_SELECT_PORT0:
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 6   

 288   2                  //msWrite2ByteMask(REG_11210A, bFlag? 0: BIT3, BIT3); // REG_COMBO_PHY1_05[3]: 
 289   2                  break;
 290   2      
 291   2              case MHL_INPUT_SELECT_PORT1:
 292   2                  //msWrite2ByteMask(REG_11230A, bFlag? 0: BIT3, BIT3); // REG_COMBO_PHY3_05[3]: 
 293   2                  break;
 294   2      
 295   2              case MHL_INPUT_SELECT_PORT2:
 296   2              case MHL_INPUT_SELECT_PORT3:
 297   2                  //msWrite2ByteMask(REG_160C4E, bFlag? 0: BIT0, BIT0); // REG_DVI_DTOP_DUAL_27[0], port 2-3 dua
             -l mhl enable ; [1]:packed-pixel mode enable 
 298   2                  break;
 299   2      
 300   2              default:
 301   2      
 302   2                  break;
 303   2          };
 304   1      
 305   1          bFlag = FALSE;
 306   1      }
 307          
 308          //**************************************************************************
 309          //  [Function Name]:
 310          //                  _mhal_mhl_SetCbusPullUp1K()
 311          //  [Description]
 312          //                  
 313          //  [Arguments]:
 314          //                  
 315          //  [Return]:
 316          //                  
 317          //**************************************************************************
 318          void _mhal_mhl_SetCbusPullUp1K(BYTE ucPortSelect, Bool bSetFlag)
 319          {
 320   1          switch(ucPortSelect)
 321   1          {
 322   2              case MHL_INPUT_SELECT_PORT0:
 323   2                  
 324   2                  break;
 325   2      
 326   2              case MHL_INPUT_SELECT_PORT1:
 327   2                  
 328   2                  break;
 329   2      
 330   2              case MHL_INPUT_SELECT_PORT2:
 331   2                  msWriteByteMask(REG_003340, bSetFlag? BIT5: 0, BIT5); // REG_PM_MHL_CBUS2_20[5], Cbus pull up 
             -1K port2
 332   2                  break;
 333   2      
 334   2              case MHL_INPUT_SELECT_PORT3:
 335   2                  msWriteByteMask(REG_003540, bSetFlag? BIT5: 0, BIT5); // REG_PM_MHL_CBUS3_20[5], Cbus pull up 
             -1K port3
 336   2                  break;
 337   2                  
 338   2              default:
 339   2      
 340   2                  break;
 341   2          };
 342   1      }
 343          
 344          //**************************************************************************
 345          //  [Function Name]:
 346          //                  _mhal_mhl_SetPadPullUp1K()
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 7   

 347          //  [Description]
 348          //                  
 349          //  [Arguments]:
 350          //                  
 351          //  [Return]:
 352          //                  
 353          //**************************************************************************
 354          void _mhal_mhl_SetPadPullUp1K(BYTE ucPortSelect, Bool bFlag)
 355          {
 356   1          switch(ucPortSelect)
 357   1          {
 358   2              case MHL_INPUT_SELECT_PORT0:
 359   2                  msWriteByteMask(REG_000468, bFlag? BIT0: 0, BIT3); // REG_PAD_TOP_34[3], Enable GPIOX02 pull-u
             -p 1k
 360   2                  break;
 361   2      
 362   2              case MHL_INPUT_SELECT_PORT1:
 363   2                  msWriteByteMask(REG_000468, bFlag? BIT1: 0, BIT4); // REG_PAD_TOP_34[4], Enable GPIOX02 pull-u
             -p 1k
 364   2                  break;
 365   2      
 366   2              case MHL_INPUT_SELECT_PORT2:
 367   2                  msWriteByteMask(REG_000468, bFlag? BIT2: 0, BIT1); // REG_PAD_TOP_34[1], Enable GPIOX02 pull-u
             -p 1k
 368   2                  break;
 369   2      
 370   2              case MHL_INPUT_SELECT_PORT3:
 371   2                  msWriteByteMask(REG_000468, bFlag? BIT3: 0, BIT2); // REG_PAD_TOP_34[2], Enable GPIOX02 pull-u
             -p 1k
 372   2                  break;
 373   2                  
 374   2              default:
 375   2      
 376   2                  break;
 377   2          };
 378   1      }
 379          
 380          //**************************************************************************
 381          //  [Function Name]:
 382          //                  _mhal_mhl_ECbusMuxSwitch()
 383          //  [Description]
 384          //                  
 385          //  [Arguments]:
 386          //                  
 387          //  [Return]:
 388          //                  
 389          //**************************************************************************
 390          void _mhal_mhl_ECbusMuxSwitch(BYTE ucECbusMux)
 391          {
 392   1          BYTE ucECbusMuxValue = 0;
 393   1          
 394   1          SET_MHL_ECBUS_MUX_SELECT(ucECbusMux);
 395   1      
 396   1          switch(ucECbusMux)
 397   1          {
 398   2              case MHL_ECBUS_MUX_SELECT_PORT2:
 399   2                  msWriteByteMask(REG_000391, 0x10, MASKBIT(5:4)| MASKBIT(1:0)); // REG_PM_BANK_48[13:12][9:8]: 
             -ECbus clock select
 400   2                  
 401   2                  ucECbusMuxValue = 2;
 402   2                  
 403   2                  break;
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 8   

 404   2      
 405   2              case MHL_ECBUS_MUX_SELECT_PORT3:
 406   2                  msWriteByteMask(REG_000391, 0x01, MASKBIT(5:4)| MASKBIT(1:0)); // REG_PM_BANK_48[13:12][9:8]: 
             -ECbus clock select
 407   2                  
 408   2                  ucECbusMuxValue = 3;
 409   2                  
 410   2                  break;
 411   2      
 412   2              default:
 413   2                  // ECbus mux none is 0
 414   2                  break;
 415   2          };
 416   1      
 417   1          // Switch ECbus mux
 418   1          msWriteByteMask(REG_00170A, ucECbusMuxValue, MASKBIT(2:0)); // REG_PM_BANK_05[2:0], eCbus mux
 419   1          // Cbus reset
 420   1          msWriteByteMask(REG_003300, BIT0, BIT0); // REG_PM_MHL_CBUS2_00[0]: Cbus soft reset
 421   1          msWriteByteMask(REG_003300, 0, BIT0); // REG_PM_MHL_CBUS2_00[0]: Cbus soft reset
 422   1      }
 423          
 424          #else
              //**************************************************************************
              //  [Function Name]:
              //                  _mhal_mhl_SetCableDetect()
              //  [Description]
              //                  
              //  [Arguments]:
              //
              //  [Return]:
              //                  
              //**************************************************************************
              void _mhal_mhl_SetCableDetect(BYTE ucPortSelect, Bool bFlag)
              {
                  switch(ucPortSelect)
                  {
                      case MHL_INPUT_SELECT_PORT0:
                          if(bFlag)
                          {
                              msWriteByteMask(REG_002F01, MASKBIT(1:0), MASKBIT(1:0)); // REG_PM_MHL_CBUS0_00[9:8], SW c
             -ontrol cable detect
                          }
                          else
                          {
                              msWriteByteMask(REG_002F01, BIT1, MASKBIT(1:0)); // REG_PM_MHL_CBUS0_00[9:8], SW control c
             -able detect
                          }
                          
                          break;
              
                      case MHL_INPUT_SELECT_PORT1:
                          if(bFlag)
                          {
                              msWriteByteMask(REG_003101, MASKBIT(1:0), MASKBIT(1:0)); // REG_PM_MHL_CBUS1_00[9:8], SW c
             -ontrol cable detect
                          }
                          else
                          {
                              msWriteByteMask(REG_003101, BIT1, MASKBIT(1:0)); // REG_PM_MHL_CBUS1_00[9:8], SW control c
             -able detect
                          }
                          
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 9   

                          break;
              
                      case MHL_INPUT_SELECT_PORT2:
                          if(bFlag)
                          {
                              msWriteByteMask(REG_003301, MASKBIT(1:0), MASKBIT(1:0)); // REG_PM_MHL_CBUS2_00[9:8], SW c
             -ontrol cable detect
                          }
                          else
                          {
                              msWriteByteMask(REG_003301, BIT1, MASKBIT(1:0)); // REG_PM_MHL_CBUS2_00[9:8], SW control c
             -able detect
                          }
                          
                          break;
              
                      case MHL_INPUT_SELECT_PORT3:
                          if(bFlag)
                          {
                              msWriteByteMask(REG_003501, MASKBIT(1:0), MASKBIT(1:0)); // REG_PM_MHL_CBUS3_00[9:8], SW c
             -ontrol cable detect
                          }
                          else
                          {
                              msWriteByteMask(REG_003501, BIT1, MASKBIT(1:0)); // REG_PM_MHL_CBUS3_00[9:8], SW control c
             -able detect
                          }
                          
                          break;
              
                      case MHL_INPUT_SELECT_PORT4:
                          if(bFlag)
                          {
                              msWriteByteMask(REG_003701, MASKBIT(1:0), MASKBIT(1:0)); // REG_PM_MHL_CBUS4_00[9:8], SW c
             -ontrol cable detect
                          }
                          else
                          {
                              msWriteByteMask(REG_003701, BIT1, MASKBIT(1:0)); // REG_PM_MHL_CBUS4_00[9:8], SW control c
             -able detect
                          }
                          
                          break;
              
                      case MHL_INPUT_SELECT_PORT5:
                          if(bFlag)
                          {
                              msWriteByteMask(REG_003901, MASKBIT(1:0), MASKBIT(1:0)); // REG_PM_MHL_CBUS5_00[9:8], SW c
             -ontrol cable detect
                          }
                          else
                          {
                              msWriteByteMask(REG_003901, BIT1, MASKBIT(1:0)); // REG_PM_MHL_CBUS5_00[9:8], SW control c
             -able detect
                          }
                          
                          break;
              
                      default:
              
                          break;
                  };
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 10  

              }
              
              //**************************************************************************
              //  [Function Name]:
              //                  _mhal_mhl_CbusPadEnable()
              //  [Description]
              //                  
              //  [Arguments]:
              //
              //  [Return]:
              //                  
              //**************************************************************************
              void _mhal_mhl_CbusPadEnable(BYTE ucPortSelect, Bool bEnableCbus)
              {
                  switch(ucPortSelect)
                  {
                      case MHL_INPUT_SELECT_PORT0:
                          msWrite2ByteMask(REG_000460, bEnableCbus? BIT0: 0, BIT0); // REG_PAD_TOP_30[0], Cbus port0 ena
             -ble
                          break;
              
                      case MHL_INPUT_SELECT_PORT1:
                          msWrite2ByteMask(REG_000460, bEnableCbus? BIT1: 0, BIT1); // REG_PAD_TOP_30[1], Cbus port1 ena
             -ble
                          break;
              
                      case MHL_INPUT_SELECT_PORT2:
                          msWrite2ByteMask(REG_000460, bEnableCbus? BIT2: 0, BIT2); // REG_PAD_TOP_30[2], Cbus port2 ena
             -ble
                          break;
              
                      case MHL_INPUT_SELECT_PORT3:
                          msWrite2ByteMask(REG_000460, bEnableCbus? BIT3: 0, BIT3); // REG_PAD_TOP_30[3], Cbus port3 ena
             -ble
                          break;
              
                      case MHL_INPUT_SELECT_PORT4:
                          msWrite2ByteMask(REG_000460, bEnableCbus? BIT4: 0, BIT4); // REG_PAD_TOP_30[4], Cbus port4 ena
             -ble
                          break;
              
                      case MHL_INPUT_SELECT_PORT5:
                          msWrite2ByteMask(REG_000460, bEnableCbus? BIT5: 0, BIT5); // REG_PAD_TOP_30[5], Cbus port5 ena
             -ble
                          break;
              
                      default:
              
                          break;
                  };
              }
              
              //**************************************************************************
              //  [Function Name]:
              //                  _mhal_mhl_SetVbusCharge()
              //  [Description]
              //                  
              //  [Arguments]:
              //
              //  [Return]:
              //                  
              //**************************************************************************
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 11  

              void _mhal_mhl_SetVbusCharge(BYTE ucPortSelect, Bool bFlag)
              {
                  switch(ucPortSelect)
                  {
                      case MHL_INPUT_SELECT_PORT0:
                          if(bFlag)
                          {
                              SET_MHL_VBUS_CHARGE_PORT0();
                          }
                          else
                          {
                              CLR_MHL_VBUS_CHARGE_PORT0();
                          }
                          
                          break;
              
                      case MHL_INPUT_SELECT_PORT1:
                          if(bFlag)
                          {
                              SET_MHL_VBUS_CHARGE_PORT1();
                          }
                          else
                          {
                              CLR_MHL_VBUS_CHARGE_PORT1();
                          }
                          
                          break;
              
                      case MHL_INPUT_SELECT_PORT2:
                          if(bFlag)
                          {
                              SET_MHL_VBUS_CHARGE_PORT2();
                          }
                          else
                          {
                              CLR_MHL_VBUS_CHARGE_PORT2();
                          }
                          
                          break;
              
                      case MHL_INPUT_SELECT_PORT3:
                          if(bFlag)
                          {
                              SET_MHL_VBUS_CHARGE_PORT3();
                          }
                          else
                          {
                              CLR_MHL_VBUS_CHARGE_PORT3();
                          }
                          
                          break;
              
                      case MHL_INPUT_SELECT_PORT4:
                          if(bFlag)
                          {
                              SET_MHL_VBUS_CHARGE_PORT4();
                          }
                          else
                          {
                              CLR_MHL_VBUS_CHARGE_PORT4();
                          }
                          
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 12  

                          break;
              
                      case MHL_INPUT_SELECT_PORT5:
                          if(bFlag)
                          {
                              SET_MHL_VBUS_CHARGE_PORT5();
                          }
                          else
                          {
                              CLR_MHL_VBUS_CHARGE_PORT5();
                          }
                          
                          break;
              
                      default:
              
                          break;
                  };
              }
              
              //**************************************************************************
              //  [Function Name]:
              //                  _mhal_mhl_OpenCommonModeResistor()
              //  [Description]
              //                  
              //  [Arguments]:
              //
              //  [Return]:
              //                  
              //**************************************************************************
              void _mhal_mhl_OpenCommonModeResistor(BYTE ucPortSelect, Bool bFlag)
              {
                  switch(ucPortSelect)
                  {
                      case MHL_INPUT_SELECT_PORT0:
                          msWrite2ByteMask(REG_0017A4, bFlag? 0: BIT8, BIT8); // REG_PM_BANK_52[8], overwrite port0 enab
             -le mhl mode in sw mode
                          break;
              
                      case MHL_INPUT_SELECT_PORT1:
                          msWrite2ByteMask(REG_0017A4, bFlag? 0: BIT9, BIT9); // REG_PM_BANK_52[9], overwrite port1 enab
             -le mhl mode in sw mode
                          break;
              
                      case MHL_INPUT_SELECT_PORT2:
                          msWrite2ByteMask(REG_0017A4, bFlag? 0: BIT10, BIT10); // REG_PM_BANK_52[10], overwrite port2 e
             -nable mhl mode in sw mode
                          break;
              
                      case MHL_INPUT_SELECT_PORT3:
                          msWrite2ByteMask(REG_0017A4, bFlag? 0: BIT11, BIT11); // REG_PM_BANK_52[11], overwrite port3 e
             -nable mhl mode in sw mode
                          break;
              
                      case MHL_INPUT_SELECT_PORT4:
                          msWrite2ByteMask(REG_0017A4, bFlag? 0: BIT12, BIT12); // REG_PM_BANK_52[12], overwrite port4 e
             -nable mhl mode in sw mode
                          break;
              
                      case MHL_INPUT_SELECT_PORT5:
                          msWrite2ByteMask(REG_0017A4, bFlag? 0: BIT13, BIT13); // REG_PM_BANK_52[13], overwrite port5 e
             -nable mhl mode in sw mode
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 13  

                          break;
              
                      default:
              
                          break;
                  };
              }
              
              //**************************************************************************
              //  [Function Name]:
              //                  _mhal_mhl_SetPadPullUp1K()
              //  [Description]
              //                  
              //  [Arguments]:
              //                  
              //  [Return]:
              //                  
              //**************************************************************************
              void _mhal_mhl_SetPadPullUp1K(BYTE ucPortSelect, Bool bFlag)
              {
                  switch(ucPortSelect)
                  {
                      case MHL_INPUT_SELECT_PORT0:
                          msWriteByteMask(REG_000468, bFlag? BIT0: 0, BIT0); // REG_PAD_TOP_34[0], Enable GPIOX02 pull-u
             -p 1k
                          break;
              
                      case MHL_INPUT_SELECT_PORT1:
                          msWriteByteMask(REG_000468, bFlag? BIT1: 0, BIT1); // REG_PAD_TOP_34[1], Enable GPIOX02 pull-u
             -p 1k
                          break;
              
                      case MHL_INPUT_SELECT_PORT2:
                          msWriteByteMask(REG_000468, bFlag? BIT2: 0, BIT2); // REG_PAD_TOP_34[2], Enable GPIOX02 pull-u
             -p 1k
                          break;
              
                      case MHL_INPUT_SELECT_PORT3:
                          msWriteByteMask(REG_000468, bFlag? BIT3: 0, BIT3); // REG_PAD_TOP_34[3], Enable GPIOX02 pull-u
             -p 1k
                          break;
              
                      case MHL_INPUT_SELECT_PORT4:
                          msWriteByteMask(REG_000468, bFlag? BIT4: 0, BIT4); // REG_PAD_TOP_34[4], Enable GPIOX02 pull-u
             -p 1k
                          break;
              
                      case MHL_INPUT_SELECT_PORT5:
                          msWriteByteMask(REG_000468, bFlag? BIT5: 0, BIT5); // REG_PAD_TOP_34[5], Enable GPIOX02 pull-u
             -p 1k
                          break;
                          
                      default:
              
                          break;
                  };
              }
              
              #endif
 742          
 743          //-------------------------------------------------------------------------------------------------
 744          //  Global Functions
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 14  

 745          //-------------------------------------------------------------------------------------------------
 746          
 747          //**************************************************************************
 748          //  [Function Name]:
 749          //                  mhal_mhl_TimerHandler()
 750          //  [Description]
 751          //                  
 752          //  [Arguments]:
 753          //                  
 754          //  [Return]:
 755          //
 756          //**************************************************************************
 757          void mhal_mhl_TimerHandler(void)
 758          {
 759   1          if(GET_MHL_MUX_SWITCH_TIMER() > 0)
 760   1          {
 761   2              DEC_MHL_MUX_SWITCH_TIMER();
 762   2          }
 763   1      }
 764          
 765          #if(CHIP_ID == MST9U3)
 766          //**************************************************************************
 767          //  [Function Name]:
 768          //                  mhal_mhl_CableDetect()
 769          //  [Description]
 770          //                  MHL cable detection
 771          //  [Arguments]:
 772          //                  
 773          //  [Return]:
 774          //                  TRUE: MHL cable plugged
 775          //                  FALSE: MHL cable unplugged
 776          //**************************************************************************
 777          Bool mhal_mhl_CableDetect(BYTE ucPortSelect)
 778          {
 779   1          Bool bCableDetect = FALSE;
 780   1      
 781   1          // Use SAR to check MHL cable attach
 782   1          switch(ucPortSelect)
 783   1          {
 784   2              case MHL_INPUT_SELECT_PORT0:
 785   2        #if(CABLE_DET_DVI0_SAR)
                          if(MHL_CABLE_SAR_DETECT_PORT0 > MHL_CABLE_DETECT_LEVEL)
                          {
                              bCableDetect = TRUE;
                          }
                #endif
 791   2        
 792   2                  break;
 793   2      
 794   2              case MHL_INPUT_SELECT_PORT1:
 795   2         #if(CABLE_DET_DVI1_SAR)
                          if(MHL_CABLE_SAR_DETECT_PORT1 > MHL_CABLE_DETECT_LEVEL)
                          {
                              bCableDetect = TRUE;
                          }
                  #endif
 801   2          
 802   2                  break;
 803   2      
 804   2              case MHL_INPUT_SELECT_PORT2:
 805   2          #if(CABLE_DET_DVI2_SAR_EN)        
                          if(MHL_CABLE_SAR_DETECT_PORT2 > MHL_CABLE_DETECT_LEVEL)
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 15  

                          {
                              bCableDetect = TRUE;
                          }
                  #endif
 811   2                  
 812   2                  break;
 813   2      
 814   2              case MHL_INPUT_SELECT_PORT3:
 815   2          #if(CABLE_DET_DVI3_SAR_EN)
                          if(MHL_CABLE_SAR_DETECT_PORT3 > MHL_CABLE_DETECT_LEVEL)
                          {
                              bCableDetect = TRUE;
                          }
                  #endif
 821   2                  
 822   2                  break;
 823   2      
 824   2              default:
 825   2      
 826   2                  break;
 827   2          };
 828   1      
 829   1          return bCableDetect;
 830   1      }
 831          
 832          //**************************************************************************
 833          //  [Function Name]:
 834          //                  mhal_mhl_CbusConnectStatus()
 835          //  [Description]:
 836          //                  MHL Cbus status
 837          //  [Arguments]:
 838          //
 839          //  [Return]:
 840          //                  Cbus status value      
 841          //**************************************************************************
 842          Bool mhal_mhl_CbusConnectStatus(BYTE ucPortSelect)
 843          {
 844   1          Bool bCbusConnect = FALSE;
 845   1          BYTE ucCbusStatus = 0;
 846   1      
 847   1          switch(ucPortSelect)
 848   1          {
 849   2              case MHL_INPUT_SELECT_PORT0:
 850   2                  ucCbusStatus = msReadByte(REG_002F2E); // REG_PM_MHL_CBUS0_17[1:0], link layer status
 851   2                  break;
 852   2      
 853   2              case MHL_INPUT_SELECT_PORT1:
 854   2                  ucCbusStatus = msReadByte(REG_00312E); // REG_PM_MHL_CBUS1_17[1:0], link layer status
 855   2                  break;
 856   2      
 857   2              case MHL_INPUT_SELECT_PORT2:
 858   2              case MHL_INPUT_SELECT_PORT3:
 859   2                  if(_mhal_mhl_GetECbusMux(ucPortSelect) == GET_MHL_ECBUS_MUX_SELECT())
 860   2                  {
 861   3                      ucCbusStatus = msReadByte(REG_00332E); // REG_PM_MHL_CBUS2_17[1:0], link layer status
 862   3                  }
 863   2                  
 864   2                  break;
 865   2      
 866   2              default:
 867   2      
 868   2                  break;
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 16  

 869   2          };
 870   1      
 871   1          if(ucCbusStatus == 0x03)
 872   1          {
 873   2              bCbusConnect = TRUE;
 874   2          }
 875   1      
 876   1          return bCbusConnect;
 877   1      }
 878          
 879          //**************************************************************************
 880          //  [Function Name]:
 881          //                  mhal_mhl_ComboRtermControl()
 882          //  [Description]
 883          //                  MHL TMDS termination resistor control
 884          //  [Arguments]:
 885          //
 886          //  [Return]:
 887          //                  
 888          //**************************************************************************
 889          void mhal_mhl_ComboRtermControl(BYTE ucPortSelect, RXRtermControl_T ucControl) 
 890          {
 891   1          switch(ucPortSelect)
 892   1          {
 893   2              case MHL_INPUT_SELECT_PORT0:
 894   2                  if(ucControl == RX_HDMI_RTERM)
 895   2                  {
 896   3                      //msWriteByteMask(REG_112107, 0, MASKBIT(2:0)); // REG_COMBO_PHY1_03[10:8], Power on port0
             - rterm.
 897   3                  }
 898   2                  else if(ucControl == RX_MHL_RTERM)
 899   2                  {
 900   3                      //msWriteByteMask(REG_112107, 0, BIT0); // REG_COMBO_PHY1_03[10:8], Power on port0's ch0 r
             -term.
 901   3                  }
 902   2                  else if(ucControl == RX_RTERM_OFF)
 903   2                  {
 904   3                      //msWriteByteMask(REG_112107, BIT0, BIT0); // REG_COMBO_PHY1_03[10:8], Power down port0 rt
             -erm.
 905   3                  }
 906   2                  
 907   2                  break;
 908   2      
 909   2              case MHL_INPUT_SELECT_PORT1:
 910   2                  if(ucControl == RX_HDMI_RTERM)
 911   2                  {
 912   3                      //msWriteByteMask(REG_112307, 0, MASKBIT(2:0)); // REG_COMBO_PHY3_03[10:8], Power on port1
             - rterm.
 913   3                  }
 914   2                  else if(ucControl == RX_MHL_RTERM)
 915   2                  {
 916   3                      //msWriteByteMask(REG_112307, 0, BIT0); // REG_COMBO_PHY3_03[10:8], Power on port1's ch0 r
             -term.
 917   3                  }
 918   2                  else if(ucControl == RX_RTERM_OFF)
 919   2                  {
 920   3                      //msWriteByteMask(REG_112307, BIT0, BIT0); // REG_COMBO_PHY3_03[10:8], Power down port1 rt
             -erm.
 921   3                  }
 922   2                  
 923   2                  break;
 924   2      
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 17  

 925   2              case MHL_INPUT_SELECT_PORT2:
 926   2                  if(ucControl == RX_HDMI_RTERM)
 927   2                  {
 928   3                      msWriteByteMask(REG_001720, 0, MASKBIT(3:0)); // REG_PM_BANK_10[3:0], Power on port2 rterm
             -.
 929   3                  }
 930   2                  else if(ucControl == RX_MHL_RTERM)
 931   2                  {
 932   3                      //msWriteByteMask(REG_001720, 0, MASKBIT(2:1)); // REG_PM_BANK_10[3:0], Power on port2's c
             -h0 rterm.
 933   3                      msWriteByteMask(REG_001720, 0, BIT0); // REG_PM_BANK_10[3:0], Power on port2's ch0 rterm. 
 934   3                  }
 935   2                  else if(ucControl == RX_RTERM_OFF)
 936   2                  {
 937   3                      //msWriteByteMask(REG_001720, MASKBIT(2:1), MASKBIT(2:1)); // REG_PM_BANK_10[3:0], Power d
             -own port2 rterm.
 938   3                      msWriteByteMask(REG_001720, BIT0, BIT0); // REG_PM_BANK_10[3:0], Power down port2 rterm. 
 939   3                  }
 940   2                  
 941   2                  break;
 942   2      
 943   2              case MHL_INPUT_SELECT_PORT3:
 944   2                  if(ucControl == RX_HDMI_RTERM)
 945   2                  {
 946   3                      msWriteByteMask(REG_001722, 0, MASKBIT(3:0)); // REG_PM_BANK_11[3:0], Power on port3 rterm
             -.
 947   3                  }
 948   2                  else if(ucControl == RX_MHL_RTERM)
 949   2                  {
 950   3                      //msWriteByteMask(REG_001722, 0, MASKBIT(2:1)); // REG_PM_BANK_11[3:0], Power on port3's c
             -h0 rterm.
 951   3                      msWriteByteMask(REG_001722, 0, BIT0); // REG_PM_BANK_11[3:0], Power on port3's ch0 rterm. 
 952   3                  }
 953   2                  else if(ucControl == RX_RTERM_OFF)
 954   2                  {
 955   3                      //msWriteByteMask(REG_001722, MASKBIT(2:1), MASKBIT(2:1)); // REG_PM_BANK_11[3:0], Power d
             -own port3 rterm.
 956   3                      msWriteByteMask(REG_001722, BIT0, BIT0); // REG_PM_BANK_11[3:0], Power on port3's ch0 rter
             -m. 
 957   3                  }
 958   2                  
 959   2                  break;
 960   2      
 961   2              default:
 962   2      
 963   2                  break;
 964   2          };
 965   1      }
 966          
 967          //**************************************************************************
 968          //  [Function Name]:
 969          //                  mhal_mhl_RtermControlHWMode()
 970          //  [Description]:
 971          //                  
 972          //  [Arguments]:
 973          //
 974          //  [Return]:
 975          //                  
 976          //**************************************************************************
 977          void mhal_mhl_RtermControlHWMode(BYTE ucPortSelect, Bool bRtermHW)
 978          {
 979   1          switch(ucPortSelect)
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 18  

 980   1          {
 981   2              case MHL_INPUT_SELECT_PORT0:
 982   2                  msWriteByteMask(REG_001707, bRtermHW? BIT4: 0, BIT4); // REG_PM_BANK_03[12], Cbus control port
             -0 rterm.
 983   2                  break;
 984   2      
 985   2              case MHL_INPUT_SELECT_PORT1:
 986   2                  msWriteByteMask(REG_001707, bRtermHW? BIT5: 0, BIT5); // REG_PM_BANK_03[13], Cbus control port
             -1 rterm.
 987   2                  break;
 988   2      
 989   2              case MHL_INPUT_SELECT_PORT2:
 990   2                  msWriteByteMask(REG_001707, bRtermHW? BIT6: 0, BIT6); // REG_PM_BANK_03[14], Cbus control port
             -2 rterm.
 991   2                  break;
 992   2      
 993   2              case MHL_INPUT_SELECT_PORT3:
 994   2                  msWriteByteMask(REG_001707, bRtermHW? BIT7: 0, BIT7); // REG_PM_BANK_03[15], Cbus control port
             -3 rterm.
 995   2                  break;
 996   2      
 997   2              default:
 998   2      
 999   2                  break;
1000   2          };
1001   1      }
1002          
1003          //**************************************************************************
1004          //  [Function Name]:
1005          //                  mhal_mhl_SetPowerStatus()
1006          //  [Description]
1007          //
1008          //  [Arguments]:
1009          //
1010          //  [Return]:
1011          //
1012          //**************************************************************************
1013          void mhal_mhl_SetPowerStatus(BYTE ucPowerStatus)
1014          {
1015   1          BYTE ucECbusMuxValue = msReadByte(REG_00170A) &MASKBIT(2:0); // REG_PM_BANK_05[2:0], eCbus mux
1016   1          
1017   1          ucMHLPowerStatus = ucPowerStatus;
1018   1      
1019   1          switch(ucPowerStatus)
1020   1          {
1021   2              case MHL_POWER_STATUS_SAVING:
1022   2                  _mhal_mhl_EnableCbusInterrupt(FALSE);
1023   2                  CLR_MHL_CABLE_DETECT_PORT_ALL();
1024   2                  break;
1025   2                  
1026   2              case MHL_POWER_STATUS_DOWN:
1027   2                  _mhal_mhl_EnableCbusInterrupt(FALSE);
1028   2                  CLR_MHL_CABLE_DETECT_PORT_ALL();
1029   2                  break;
1030   2                  
1031   2              default:
1032   2                  
1033   2                  break;
1034   2          };
1035   1      
1036   1          if(ucECbusMuxValue == 2)
1037   1          {
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 19  

1038   2              SET_MHL_ECBUS_MUX_SELECT(MHL_ECBUS_MUX_SELECT_PORT2);
1039   2          }
1040   1          else if(ucECbusMuxValue == 3)
1041   1          {
1042   2              SET_MHL_ECBUS_MUX_SELECT(MHL_ECBUS_MUX_SELECT_PORT3);
1043   2          }
1044   1      }
1045          
1046          //**************************************************************************
1047          //  [Function Name]:
1048          //                  mhal_mhl_PMStatePolling()
1049          //  [Description]
1050          //
1051          //  [Arguments]:
1052          //
1053          //  [Return]:
1054          //
1055          //**************************************************************************
1056          void mhal_mhl_PMStatePolling(BYTE ucPortSelect)
1057          {
1058   1          Bool bCableDetect = mhal_mhl_CableDetect(ucPortSelect);
1059   1          BYTE ucECbusMux = _mhal_mhl_GetECbusMux(ucPortSelect);
1060   1      
1061   1      //printData("mhal_mhl_PMStatePolling==%d",ucPortSelect);
1062   1      
1063   1      //printData("mhal_mhl_CableDetect==%d",bCableDetect);
1064   1      //printData("GET_MHL_CABLE_DETECT_PORT(ucPortSelect)==%d",GET_MHL_CABLE_DETECT_PORT(ucPortSelect));
1065   1      
1066   1          if(GET_MHL_CABLE_DETECT_PORT(ucPortSelect) != bCableDetect)
1067   1          {
1068   2              if(ucMHLPowerStatus == MHL_POWER_STATUS_SAVING)
1069   2              {
1070   3                  // Cbus enable
1071   3                  _mhal_mhl_CbusPadEnable(ucPortSelect, bCableDetect);
1072   3              }
1073   2              else
1074   2              {
1075   3                  if(ucMHLPowerStatus == MHL_POWER_STATUS_DOWN)
1076   3                   {
1077   4                          // Cbus disable
1078   4                          _mhal_mhl_CbusPadEnable(ucPortSelect, FALSE);
1079   4                    }
1080   3      
1081   3                  // Remove Pad PU1K
1082   3                  _mhal_mhl_SetPadPullUp1K(ucPortSelect, !bCableDetect);
1083   3              }
1084   2      
1085   2              // Remove pull up 1K
1086   2              _mhal_mhl_SetCbusPullUp1K(ucPortSelect, !bCableDetect);
1087   2              // Vbus charge
1088   2              _mhal_mhl_SetVbusCharge(ucPortSelect, bCableDetect);
1089   2              // Rterm HW control
1090   2              mhal_mhl_RtermControlHWMode(ucPortSelect, bCableDetect);
1091   2      
1092   2              if(bCableDetect)
1093   2              {
1094   3                  SET_MHL_CABLE_DETECT_PORT(ucPortSelect);
1095   3              }
1096   2              else
1097   2              {
1098   3                  CLR_MHL_CABLE_DETECT_PORT(ucPortSelect);
1099   3              }
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 20  

1100   2      
1101   2              if(ucECbusMux == MHL_ECBUS_MUX_SELECT_NONE) // Not ECbus port
1102   2              {
1103   3                  if(ucMHLPowerStatus != MHL_POWER_STATUS_DOWN)
1104   3                  {
1105   4                      // Set cable detect
1106   4                      _mhal_mhl_SetCableDetect(ucPortSelect, bCableDetect);
1107   4                      // Open common mode resistor
1108   4                      _mhal_mhl_OpenCommonModeResistor(ucPortSelect, bCableDetect);
1109   4                   }
1110   3              }
1111   2              else // ECbus port
1112   2              {
1113   3                  if(!bCableDetect && (ucECbusMux == GET_MHL_ECBUS_MUX_SELECT()))
1114   3                  {
1115   4                      CLR_MHL_MUX_SWITCH_TIMER();
1116   4                  }
1117   3                  
1118   3                  if(GET_MHL_CABLE_DETECT_PORT(MHL_INPUT_SELECT_PORT2) || GET_MHL_CABLE_DETECT_PORT(MHL_INPUT_SE
             -LECT_PORT3))
1119   3                  {
1120   4                      bCableDetect = TRUE;
1121   4                  }
1122   3                  else
1123   3                  {
1124   4                      bCableDetect = FALSE;
1125   4                  }
1126   3      
1127   3                  // Set cable detect
1128   3                  _mhal_mhl_SetCableDetect(ucPortSelect, bCableDetect);
1129   3                  // Open common mode resistor
1130   3                  _mhal_mhl_OpenCommonModeResistor(ucPortSelect, bCableDetect);
1131   3              }
1132   2          }
1133   1      
1134   1          if((GET_MHL_MUX_SWITCH_TIMER() == 0) && (ucECbusMux != MHL_ECBUS_MUX_SELECT_NONE)) // Timer out & ECbu
             -s port
1135   1          {
1136   2              if(GET_MHL_CABLE_DETECT_PORT(MHL_INPUT_SELECT_PORT2) || GET_MHL_CABLE_DETECT_PORT(MHL_INPUT_SELECT
             -_PORT3)) // Check port2 &3 cable detect
1137   2              {
1138   3                  if(GET_MHL_ECBUS_MUX_SELECT() == MHL_ECBUS_MUX_SELECT_NONE) // ECbus mux none
1139   3                  {
1140   4                      // Do nothing, keep current port ECbus mux
1141   4                  }
1142   3                  else if((GET_MHL_ECBUS_MUX_SELECT() == MHL_ECBUS_MUX_SELECT_PORT2) && GET_MHL_CABLE_DETECT_POR
             -T(MHL_INPUT_SELECT_PORT3))
1143   3                  {
1144   4                      ucECbusMux = MHL_ECBUS_MUX_SELECT_PORT3;
1145   4                  }
1146   3                  else if((GET_MHL_ECBUS_MUX_SELECT() == MHL_ECBUS_MUX_SELECT_PORT3) && GET_MHL_CABLE_DETECT_POR
             -T(MHL_INPUT_SELECT_PORT2))
1147   3                  {
1148   4                      ucECbusMux = MHL_ECBUS_MUX_SELECT_PORT2;
1149   4                  }
1150   3              }
1151   2              else
1152   2              {
1153   3                  ucECbusMux = MHL_ECBUS_MUX_SELECT_NONE;
1154   3              }
1155   2      
1156   2              if(ucECbusMux != GET_MHL_ECBUS_MUX_SELECT())
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 21  

1157   2              {
1158   3                   if (ucMHLPowerStatus == MHL_POWER_STATUS_SAVING)
1159   3                      _mhal_mhl_ECbusMuxSwitch(ucECbusMux);
1160   3                   else if (ucMHLPowerStatus == MHL_POWER_STATUS_DOWN)
1161   3                      _mhal_mhl_ECbusMuxSwitch(MHL_ECBUS_MUX_SELECT_NONE);
1162   3                   
1163   3                  // Set cable detect
1164   3                  _mhal_mhl_SetCableDetect(ucPortSelect, TRUE);
1165   3                  
1166   3                  MHL_HAL_DPRINTF("MHL switch MUX to %d ", ucECbusMux);
1167   3              }
1168   2      
1169   2              if(ucECbusMux != MHL_ECBUS_MUX_SELECT_NONE)
1170   2              {
1171   3                  SET_MHL_MUX_SWITCH_TIMER(MHL_ECBUS_MUX_SWITCH_TIME);
1172   3              }
1173   2          }
1174   1      }
1175          
1176          #else
              //**************************************************************************
              //  [Function Name]:
              //                  mhal_mhl_CableDetect()
              //  [Description]
              //                  MHL cable detection
              //  [Arguments]:
              //                  
              //  [Return]:
              //                  TRUE: MHL cable plugged
              //                  FALSE: MHL cable unplugged
              //**************************************************************************
              Bool mhal_mhl_CableDetect(BYTE ucPortSelect)
              {
                  Bool bCableDetect = FALSE;
              
                  // Use SAR to check MHL cable attach
                  switch(ucPortSelect)
                  {
                      case MHL_INPUT_SELECT_PORT0:
              #if(CABLE_DET_DVI0_SAR)
                          if(MHL_CABLE_SAR_DETECT_PORT0 > MHL_CABLE_DETECT_LEVEL)
                          {
                              bCableDetect = TRUE;
                          }
              #endif
                          break;
              
                      case MHL_INPUT_SELECT_PORT1:
               #if(CABLE_DET_DVI1_SAR)
                          if(MHL_CABLE_SAR_DETECT_PORT1 > MHL_CABLE_DETECT_LEVEL)
                          {
                              bCableDetect = TRUE;
                          }
               #endif           
                          break;
              
                      case MHL_INPUT_SELECT_PORT2:
               #if(CABLE_DET_DVI2_SAR)           
                          if(MHL_CABLE_SAR_DETECT_PORT2 > MHL_CABLE_DETECT_LEVEL)
                          {
                              bCableDetect = TRUE;
                          }
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 22  

                #endif          
                
                          break;
              
                      case MHL_INPUT_SELECT_PORT3:
                #if(CABLE_DET_DVI3_SAR)          
                          if(MHL_CABLE_SAR_DETECT_PORT3 > MHL_CABLE_DETECT_LEVEL)
                          {
                              bCableDetect = TRUE;
                          }
                #endif           
                
                          break;
              
                      case MHL_INPUT_SELECT_PORT4:
                #if(CABLE_DET_DVI4_SAR)          
                          if(MHL_CABLE_SAR_DETECT_PORT4 > MHL_CABLE_DETECT_LEVEL)
                          {
                              bCableDetect = TRUE;
                          }
                #endif
                        
                          break;
                
                      case MHL_INPUT_SELECT_PORT5:
                #if(CABLE_DET_DVI5_SAR)
                          if(MHL_CABLE_SAR_DETECT_PORT5 > MHL_CABLE_DETECT_LEVEL)
                          {
                              bCableDetect = TRUE;
                          }
                  #endif
                        
                          break;
                
                      default:
              
                          break;
                  };
              
                  return bCableDetect;
              }
              
              //**************************************************************************
              //  [Function Name]:
              //                  mhal_mhl_CbusConnectStatus()
              //  [Description]:
              //                  MHL Cbus status
              //  [Arguments]:
              //
              //  [Return]:
              //                  Cbus status value      
              //**************************************************************************
              Bool mhal_mhl_CbusConnectStatus(BYTE ucPortSelect)
              {
                  Bool bCbusConnect = FALSE;
                  BYTE ucCbusStatus = 0;
              
                  switch(ucPortSelect)
                  {
                      case MHL_INPUT_SELECT_PORT0:
                          ucCbusStatus = msReadByte(REG_002F2E); // REG_PM_MHL_CBUS0_17[1:0], link layer status
                          break;
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 23  

              
                      case MHL_INPUT_SELECT_PORT1:
                          ucCbusStatus = msReadByte(REG_00312E); // REG_PM_MHL_CBUS1_17[1:0], link layer status
                          break;
              
                      case MHL_INPUT_SELECT_PORT2:
                          ucCbusStatus = msReadByte(REG_00332E); // REG_PM_MHL_CBUS2_17[1:0], link layer status
                          break;
              
                      case MHL_INPUT_SELECT_PORT3:
                          ucCbusStatus = msReadByte(REG_00352E); // REG_PM_MHL_CBUS3_17[1:0], link layer status
                          break;
              
                      case MHL_INPUT_SELECT_PORT4:
                          ucCbusStatus = msReadByte(REG_00372E); // REG_PM_MHL_CBUS4_17[1:0], link layer status
                          break;
              
                      case MHL_INPUT_SELECT_PORT5:
                          ucCbusStatus = msReadByte(REG_00392E); // REG_PM_MHL_CBUS5_17[1:0], link layer status
                          break;
              
                      default:
              
                          break;
                  };
              
                  if(ucCbusStatus == 0x03)
                  {
                      bCbusConnect = TRUE;
                  }
              
                  return bCbusConnect;
              }
              
              //**************************************************************************
              //  [Function Name]:
              //                  mhal_mhl_ComboRtermControl()
              //  [Description]
              //                  MHL TMDS termination resistor control
              //  [Arguments]:
              //
              //  [Return]:
              //                  
              //**************************************************************************
              void mhal_mhl_ComboRtermControl(BYTE ucPortSelect, RXRtermControl_T ucControl) 
              {
                  switch(ucPortSelect)
                  {
                      case MHL_INPUT_SELECT_PORT0:
                          if(ucControl == RX_HDMI_RTERM)
                          {
                              msWriteByteMask(REG_0017C4, 0, MASKBIT(3:0)); // REG_PM_BANK_62[3:0], Power on port0 rterm
             -.
                          }
                          else if(ucControl == RX_MHL_RTERM)
                          {
                              msWriteByteMask(REG_0017C4, 0, MASKBIT(2:1)); // REG_PM_BANK_62[3:0], Power on port0's ch0
             - rterm.
                          }
                          else if(ucControl == RX_RTERM_OFF)
                          {
                              msWriteByteMask(REG_0017C4, MASKBIT(2:1), MASKBIT(2:1)); // REG_PM_BANK_62[3:0], Power dow
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 24  

             -n port0 rterm.
                          }
                          
                          break;
              
                      case MHL_INPUT_SELECT_PORT1:
                          if(ucControl == RX_HDMI_RTERM)
                          {
                              msWriteByteMask(REG_0017C4, 0, MASKBIT(7:4)); // REG_PM_BANK_62[7:4], Power on port1 rterm
             -.
                          }
                          else if(ucControl == RX_MHL_RTERM)
                          {
                              msWriteByteMask(REG_0017C4, 0, MASKBIT(6:5)); // REG_PM_BANK_62[7:4], Power on port1's ch0
             - rterm.
                          }
                          else if(ucControl == RX_RTERM_OFF)
                          {
                              msWriteByteMask(REG_0017C4, MASKBIT(6:5), MASKBIT(6:5)); // REG_PM_BANK_62[7:4], Power dow
             -n port1 rterm.
                          }
                          
                          break;
              
                      case MHL_INPUT_SELECT_PORT2:
                          if(ucControl == RX_HDMI_RTERM)
                          {
                              msWriteByteMask(REG_0017C5, 0, MASKBIT(3:0)); // REG_PM_BANK_62[11:8], Power on port2 rter
             -m.
                          }
                          else if(ucControl == RX_MHL_RTERM)
                          {
                              msWriteByteMask(REG_0017C5, 0, MASKBIT(2:1)); // REG_PM_BANK_62[11:8], Power on port2's ch
             -0 rterm.
                          }
                          else if(ucControl == RX_RTERM_OFF)
                          {
                              msWriteByteMask(REG_0017C5, MASKBIT(2:1), MASKBIT(2:1)); // REG_PM_BANK_62[11:8], Power do
             -wn port2 rterm.
                          }
                          
                          break;
              
                      case MHL_INPUT_SELECT_PORT3:
                          if(ucControl == RX_HDMI_RTERM)
                          {
                              msWriteByteMask(REG_0017A2, 0, MASKBIT(3:0)); // REG_PM_BANK_51[3:0], Power on port3 rterm
             -.
                          }
                          else if(ucControl == RX_MHL_RTERM)
                          {
                              msWriteByteMask(REG_0017A2, 0, MASKBIT(2:1)); // REG_PM_BANK_51[3:0], Power on port3's ch0
             - rterm.
                          }
                          else if(ucControl == RX_RTERM_OFF)
                          {
                              msWriteByteMask(REG_0017A2, MASKBIT(2:1), MASKBIT(2:1)); // REG_PM_BANK_51[3:0], Power dow
             -n port3 rterm.
                          }
                          
                          break;
              
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 25  

                      case MHL_INPUT_SELECT_PORT4:
                          if(ucControl == RX_HDMI_RTERM)
                          {
                              msWriteByteMask(REG_0017A2, 0, MASKBIT(7:4)); // REG_PM_BANK_51[7:4], Power on port4 rterm
             -.
                          }
                          else if(ucControl == RX_MHL_RTERM)
                          {
                              msWriteByteMask(REG_0017A2, 0, MASKBIT(6:5)); // REG_PM_BANK_51[7:4], Power on port4's ch0
             - rterm.
                          }
                          else if(ucControl == RX_RTERM_OFF)
                          {
                              msWriteByteMask(REG_0017A2, MASKBIT(6:5), MASKBIT(6:5)); // REG_PM_BANK_51[7:4], Power dow
             -n port4 rterm.
                          }
                          
                          break;
              
                      case MHL_INPUT_SELECT_PORT5:
                          if(ucControl == RX_HDMI_RTERM)
                          {
                              msWriteByteMask(REG_0017A3, 0, MASKBIT(3:0)); // REG_PM_BANK_51[11:8], Power on port5 rter
             -m.
                          }
                          else if(ucControl == RX_MHL_RTERM)
                          {
                              msWriteByteMask(REG_0017A3, 0, MASKBIT(2:1)); // REG_PM_BANK_51[11:8], Power on port5's ch
             -0 rterm.
                          }
                          else if(ucControl == RX_RTERM_OFF)
                          {
                              msWriteByteMask(REG_0017A3, MASKBIT(2:1), MASKBIT(2:1)); // REG_PM_BANK_51[11:8], Power do
             -wn port5 rterm.
                          }
                          
                          break;
              
                      default:
              
                          break;
                  };
              }
              
              //**************************************************************************
              //  [Function Name]:
              //                  mhal_mhl_RtermControlHWMode()
              //  [Description]:
              //                  
              //  [Arguments]:
              //
              //  [Return]:
              //                  
              //**************************************************************************
              void mhal_mhl_RtermControlHWMode(BYTE ucPortSelect, Bool bRtermHW)
              {
                  switch(ucPortSelect)
                  {
                      case MHL_INPUT_SELECT_PORT0:
                          msWriteByteMask(REG_0017C9, bRtermHW? BIT4: 0, BIT4); // REG_PM_BANK_64[12], Cbus control port
             -0 rterm.
                          break;
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 26  

              
                      case MHL_INPUT_SELECT_PORT1:
                          msWriteByteMask(REG_0017C9, bRtermHW? BIT5: 0, BIT5); // REG_PM_BANK_64[13], Cbus control port
             -1 rterm.
                          break;
              
                      case MHL_INPUT_SELECT_PORT2:
                          msWriteByteMask(REG_0017C9, bRtermHW? BIT6: 0, BIT6); // REG_PM_BANK_64[14], Cbus control port
             -2 rterm.
                          break;
              
                      case MHL_INPUT_SELECT_PORT3:
                          msWriteByteMask(REG_0017A0, bRtermHW? BIT0: 0, BIT0); // REG_PM_BANK_50[0], Cbus control port3
             - rterm.
                          break;
              
                      case MHL_INPUT_SELECT_PORT4:
                          msWriteByteMask(REG_0017A0, bRtermHW? BIT1: 0, BIT1); // REG_PM_BANK_50[1], Cbus control port4
             - rterm.
                          break;
              
                      case MHL_INPUT_SELECT_PORT5:
                          msWriteByteMask(REG_0017A0, bRtermHW? BIT2: 0, BIT2); // REG_PM_BANK_50[2], Cbus control port5
             - rterm.
                          break;
              
                      default:
              
                          break;
                  };
              }
              
              //**************************************************************************
              //  [Function Name]:
              //                  mhal_mhl_SetPowerStatus()
              //  [Description]
              //
              //  [Arguments]:
              //
              //  [Return]:
              //
              //**************************************************************************
              void mhal_mhl_SetPowerStatus(BYTE ucPowerStatus)
              {
                  ucMHLPowerStatus = ucPowerStatus;
              
                  switch(ucPowerStatus)
                  {
                      case MHL_POWER_STATUS_SAVING:
                          _mhal_mhl_EnableCbusInterrupt(FALSE);
                          CLR_MHL_CABLE_DETECT_PORT_ALL();
                          break;
                          
                      case MHL_POWER_STATUS_DOWN:
                          _mhal_mhl_EnableCbusInterrupt(FALSE);
                          CLR_MHL_CABLE_DETECT_PORT_ALL();
                          break;
                          
                      default:
                          
                          break;
                  };
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 27  

              }
              
              //**************************************************************************
              //  [Function Name]:
              //                  mhal_mhl_PMStatePolling()
              //  [Description]
              //
              //  [Arguments]:
              //
              //  [Return]:
              //
              //**************************************************************************
              void mhal_mhl_PMStatePolling(BYTE ucPortSelect)
              {
                  Bool bCableDetect = mhal_mhl_CableDetect(ucPortSelect);
              
                  if(GET_MHL_CABLE_DETECT_PORT(ucPortSelect) != bCableDetect)
                  {
                      if(ucMHLPowerStatus == MHL_POWER_STATUS_SAVING)
                      {
                          // Cbus enable
                          _mhal_mhl_CbusPadEnable(ucPortSelect, bCableDetect);
                      }
                      else
                      {
                          if(ucMHLPowerStatus == MHL_POWER_STATUS_DOWN)
                           {
                                  // Cbus disable
                                  _mhal_mhl_CbusPadEnable(ucPortSelect, FALSE);
                            }
                      
                          // Remove Pad PU1K
                          _mhal_mhl_SetPadPullUp1K(ucPortSelect, !bCableDetect);
                      }
                      
                      // Vbus charge
                      _mhal_mhl_SetVbusCharge(ucPortSelect, bCableDetect);
              
                      if(ucMHLPowerStatus != MHL_POWER_STATUS_DOWN)
                      {        
                          // Set cable detect
                          _mhal_mhl_SetCableDetect(ucPortSelect, bCableDetect);
                          // Open common mode resistor
                          _mhal_mhl_OpenCommonModeResistor(ucPortSelect, bCableDetect);
                       }
                      
                      // Rterm HW control
                      mhal_mhl_RtermControlHWMode(ucPortSelect, bCableDetect);
                      
                      if(bCableDetect)
                      {
                          SET_MHL_CABLE_DETECT_PORT(ucPortSelect);
                      }
                      else
                      {
                          CLR_MHL_CABLE_DETECT_PORT(ucPortSelect);
                      }
                  }
              }
              
              #endif
1566          
C51 COMPILER V9.00   MHAL_MHL                                                              07/03/2017 18:41:22 PAGE 28  

1567          #endif // _MHAL_MHL_C_
1568          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1479    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      5      15
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
