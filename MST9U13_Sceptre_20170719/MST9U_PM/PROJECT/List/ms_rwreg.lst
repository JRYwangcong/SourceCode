C51 COMPILER V9.00   MS_RWREG                                                              07/03/2017 18:41:19 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MS_RWREG
OBJECT MODULE PLACED IN .\Obj\ms_rwreg.obj
COMPILER INVOKED BY: C:\Keil4\C51\BIN\C51.EXE ..\Code\ms_rwreg.c OPTIMIZE(9,SPEED) BROWSE INCDIR(..\Code\INC;..\Code\DRI
                    -VER\INC;..\Code\DRIVER\MST9U\INC;..\Code\DRIVER\MST9U3\INC) DEFINE(ModelName=MST9U3_DEMO,CHIP_ID=MST9U3) DEBUG OBJECTEXT
                    -END PRINT(.\List\ms_rwreg.lst) OBJECT(.\Obj\ms_rwreg.obj)

line level    source

   1          ///////////////////////////////////////////////////////////////////////////////
   2          /// @file ms_rwreg.h
   3          /// @brief MStar Scaler register access.
   4          /// @author MStarSemi Inc.
   5          ///
   6          /// Functions for MStar scaler register access.
   7          ///
   8          /// Features
   9          ///  -Write byte/word/bulk data
  10          ///  -Read byte/word data.
  11          ///  -
  12          ///  -
  13          ///////////////////////////////////////////////////////////////////////////////
  14          #define _MS_RWREG_C
  15          
  16          #include <intrins.h>
  17          #include "types.h"
  18          #include "board.h"
  19          #include "ms_reg.h"
  20          #include "misc.h"
  21          #include "ms_rwreg.h"
  22          
  23          #define DB_DEBUG    1
  24          #if ENABLE_DEBUG&&DB_DEBUG
              #define DB_DEBUG_printData(str, value)   printData(str, value)
              #define DB_DEBUG_printMsg(str)           printMsg(str)
              #else
  28          #define DB_DEBUG_printData(str, value)
  29          #define DB_DEBUG_printMsg(str)
  30          #endif
  31          
  32          WORD idata g_u16RIUReqCnt = 0;
  33          
  34          #if ENABLE_SW_DOUBLE_BUFFER
              enum
              {
                  SW_DB_SW_TRIG,
                  SW_DB_OVSYNC_TRIG,
                  SW_DB_IVSYNC_TRIG,
                  SW_DB_OVDE_TRIG,
              };
              
              XDATA StuSWDBCtrl SWDBCtrl _at_ XDATA_SWDB_ADDR_START;
              void msSWDBInit(void)
              {
                  SWDBCtrl.ucSWDB_Mode = eDB_NORMAL_MODE;
                  SWDBCtrl.ucSWDB_Mode_Log = eDB_NORMAL_MODE;
                  SWDBCtrl.ucSWDB_Num = 1;
                  SWDBCtrl.ucSWDB_Counter = 0;
                  SWDBCtrl.ucSWDB_OnFire = 0;
                  SWDBCtrl.ucSWDB_LastSCBank = 0xFF;
                  //msWriteByteMask(REG_003C25,SW_DB_OVDE_TRIG<<4,BIT5|BIT4);
                  msWriteByteMask(REG_003C25,SW_DB_SW_TRIG<<4,BIT5|BIT4);
C51 COMPILER V9.00   MS_RWREG                                                              07/03/2017 18:41:19 PAGE 2   

                  msWrite2ByteMask(REG_003C24,((WORD)&SWDBCtrl.ucSWDB_Buffer[0])&0x7FF,0x07FF);
                  msWriteBit(REG_002B08,0,BIT4);  //PM FIQ
                  msWriteBit(REG_002B28,0,BIT1);  //PM IRQ
                  DB_DEBUG_printMsg("ML initial");
              }
              
              void msSWDBWaitForRdy(void)
              {
                  XDATA BYTE dlycnt=60;
                  while(SWDBCtrl.ucSWDB_OnFire)
                  {
                      dlycnt--;
                      if(!dlycnt)
                      {
                          DB_DEBUG_printMsg("ML Time out, switch to SW Trig Mode !!");
                          msWriteByteMask(REG_003C25,SW_DB_SW_TRIG<<4,BIT5|BIT4);
                          msWriteByteMask(REG_003C25,BIT6,BIT6);
                          while(SWDBCtrl.ucSWDB_OnFire);
                          msWriteByteMask(REG_003C25,0x00,0xC0);
                          msWriteByteMask(REG_003C25,SW_DB_OVDE_TRIG<<4,BIT5|BIT4);
                          SWDBCtrl.ucSWDB_Counter = 0;
                          SWDBCtrl.ucSWDB_OnFire = 0;
                          break;
                      }
                      ForceDelay1ms(1);
                  }
              }
              
              void msSWDBWriteToRegister(void)
              {
                  XDATA BYTE index;
              
                  msSWDBWaitForRdy();
                  if(SWDBCtrl.ucSWDB_Counter)
                  {
                      index = SWDBCtrl.ucSWDB_Counter;
                      msWrite2ByteMask(REG_003C26,((WORD)&SWDBCtrl.ucSWDB_Buffer[index-1])&0x7FF,0x07FF);
                      SWDBCtrl.ucSWDB_OnFire = 1;
                      msWriteByte(REG_003C25,msReadByte(REG_003C25)|0xC0);
                  }
              }
              
              void msSWDBMode(DB_TYPE type)
              {
                  SWDBCtrl.ucSWDB_Mode = type;
              }
              
              static BOOL msSWDBNewModeBufChk(WORD wReg)
              {
                  BOOL NewMode = FALSE;
                  XDATA BYTE size = 4;
              
                  if((SWDBCtrl.ucSWDB_Mode_Log != SWDBCtrl.ucSWDB_Mode)
                     || (SWDBCtrl.ucSWDB_Counter == 0))
                  {
                      NewMode = TRUE;
                  }
                  else
                  {
                      switch(SWDBCtrl.ucSWDB_Mode)
                      {
                          case eDB_SUCCESSIVE_MODE:
C51 COMPILER V9.00   MS_RWREG                                                              07/03/2017 18:41:19 PAGE 3   

                              if((wReg>>8) != (SWDBCtrl.ucSWDB_Buffer[SWDBCtrl.ucSWDB_Num - 1]&0x3F))
                                  NewMode = TRUE;
                              break;
              
                          case eDB_BURST_MODE:
                              if(((wReg>>8) != (SWDBCtrl.ucSWDB_Buffer[SWDBCtrl.ucSWDB_Num - 1]&0x3F))
                                 || ((wReg&0xFF) != (SWDBCtrl.ucSWDB_Buffer[SWDBCtrl.ucSWDB_Num + 1])))
                                 NewMode = TRUE;
                              break;
              
                          default:
                              break;
                      }
                  }
              
                  // if buffer size is not large enough then write to register first
                  if(SWDBCtrl.ucSWDB_Mode == eDB_NORMAL_MODE)
                      size = 3;
                  else if(SWDBCtrl.ucSWDB_Mode == eDB_SUCCESSIVE_MODE)
                      size = NewMode?4:2;
                  else if(SWDBCtrl.ucSWDB_Mode == eDB_BURST_MODE)
                      size = NewMode?4:1;
              
                  if( (SWDBCtrl.ucSWDB_Counter+size) >= SWDB_MAX_SIZE )
                  {
                      DB_DEBUG_printMsg("SWDB buffer is Full !!");
                      msSWDBWriteToRegister();
                      msSWDBWaitForRdy();
                      NewMode = TRUE;
                  }
              
                  if(NewMode)
                      SWDBCtrl.ucSWDB_Num = SWDBCtrl.ucSWDB_Counter + 1;
              
                  return NewMode;
              }
              void msSWDBWriteByte(WORD wReg,BYTE ucValue)
              {
                  XDATA BYTE index, SWDBModeChg;
                  XDATA BYTE SCBank,SCAddr,SCVal;
              
                  msSWDBWaitForRdy();
                  if( wReg&_BIT15 ) // Scaler bank
                  {
                      SCBank = (wReg>>8)&0x7F;
                      SCAddr = (wReg&0xFF);
                      SCVal = ucValue;
                      if(SWDBCtrl.ucSWDB_LastSCBank!= SCBank)
                      {
                          SWDBCtrl.ucSWDB_LastSCBank = SCBank;
                          msSWDBWriteByte(0x2F00,SCBank);
                          msSWDBWriteByte(0x2F00|SCAddr,SCVal);
                      }
                      else
                          msSWDBWriteByte(0x2F00|SCAddr,SCVal);
                  }
                  else
                  {
                      SWDBModeChg = msSWDBNewModeBufChk(wReg);
                      index  = SWDBCtrl.ucSWDB_Counter;
              
                      switch(SWDBCtrl.ucSWDB_Mode)
C51 COMPILER V9.00   MS_RWREG                                                              07/03/2017 18:41:19 PAGE 4   

                      {
                          case eDB_NORMAL_MODE:
                              SWDBCtrl.ucSWDB_Mode_Log = SWDBCtrl.ucSWDB_Mode;
                              SWDBCtrl.ucSWDB_Buffer[index] = (wReg>>8)|eDB_NORMAL_MODE;
                              SWDBCtrl.ucSWDB_Buffer[index+1] = (wReg&0xFF);
                              SWDBCtrl.ucSWDB_Buffer[index+2] = ucValue;
                              SWDBCtrl.ucSWDB_Counter += 3;
                              break;
              
                          case eDB_SUCCESSIVE_MODE:
                              if(SWDBModeChg)
                              {
                                  SWDBCtrl.ucSWDB_Mode_Log = SWDBCtrl.ucSWDB_Mode;
                                  SWDBCtrl.ucSWDB_Buffer[SWDBCtrl.ucSWDB_Num - 1] = (wReg>>8)|eDB_SUCCESSIVE_MODE;
                                  SWDBCtrl.ucSWDB_Buffer[SWDBCtrl.ucSWDB_Num] = 0;
                                  SWDBCtrl.ucSWDB_Buffer[index + 2] = (wReg&0xFF);
                                  SWDBCtrl.ucSWDB_Buffer[index + 3] = ucValue;
                                  SWDBCtrl.ucSWDB_Counter += 4;
                              }
                              else
                              {
                                  SWDBCtrl.ucSWDB_Buffer[SWDBCtrl.ucSWDB_Num - 1] = (wReg>>8)|eDB_SUCCESSIVE_MODE;
                                  SWDBCtrl.ucSWDB_Buffer[SWDBCtrl.ucSWDB_Num]++;
                                  SWDBCtrl.ucSWDB_Buffer[index ] = (wReg&0xFF);
                                  SWDBCtrl.ucSWDB_Buffer[index + 1] = ucValue;
                                  SWDBCtrl.ucSWDB_Counter += 2;
                              }
                              break;
              
                          case eDB_BURST_MODE:
                              if(SWDBModeChg)
                              {
                                  SWDBCtrl.ucSWDB_Mode_Log = SWDBCtrl.ucSWDB_Mode;
                                  SWDBCtrl.ucSWDB_Buffer[SWDBCtrl.ucSWDB_Num - 1] = (wReg>>8)|eDB_BURST_MODE;
                                  SWDBCtrl.ucSWDB_Buffer[SWDBCtrl.ucSWDB_Num] = 0;
                                  SWDBCtrl.ucSWDB_Buffer[SWDBCtrl.ucSWDB_Num + 1] = (wReg&0xFF);
                                  SWDBCtrl.ucSWDB_Buffer[index + 3] = ucValue;
                                  SWDBCtrl.ucSWDB_Counter += 4;
                              }
                              else
                              {
                                  SWDBCtrl.ucSWDB_Buffer[SWDBCtrl.ucSWDB_Num - 1] = (wReg>>8)|eDB_BURST_MODE;
                                  SWDBCtrl.ucSWDB_Buffer[SWDBCtrl.ucSWDB_Num]++;
                                  SWDBCtrl.ucSWDB_Buffer[SWDBCtrl.ucSWDB_Num + 1 ] = (wReg&0xFF);
                                  SWDBCtrl.ucSWDB_Buffer[index] = ucValue;
                                  SWDBCtrl.ucSWDB_Counter += 1;
                              }
                              break;
                      }
                  }
              }
              
              
              void msSWDBWrite2Byte(WORD wReg,WORD wValue)
              {
                  msSWDBWriteByte(wReg, wValue );
                  msSWDBWriteByte(wReg + 1, wValue>>8);
              }
              
              void msSWDBWrite3Byte(WORD wReg, DWORD dwValue)
              {
                  msSWDBWrite2Byte( wReg, dwValue&0xFFFF );
C51 COMPILER V9.00   MS_RWREG                                                              07/03/2017 18:41:19 PAGE 5   

                  msSWDBWriteByte( wReg + 2, ( BYTE )( dwValue >> 16 ) );
              }
              
              void msSWDBWriteByteMask(WORD wReg,BYTE ucVal,BYTE ucMask)
              {
                  msSWDBWriteByte(wReg , (msReadByte( wReg ) & ( ~ucMask ) ) | ((ucVal) & (ucMask)) );
              }
              
              
              void msSWDBWrite2ByteMask(WORD wReg,WORD wVal,WORD wMask)
              {
                  msSWDBWriteByteMask(wReg, (BYTE)wVal, (BYTE)wMask);
                  msSWDBWriteByteMask(wReg+1, (BYTE)(wVal>>8), (BYTE)(wMask>>8));
              }
              
              void msSWDBWriteBit(WORD wReg,BOOL bBit,BYTE ucBitPos)
              {
                  XDATA BYTE u8Value;
              
                  u8Value = msReadByte( wReg );
                  if( bBit )
                  {
                      u8Value = u8Value | (ucBitPos);
                  }
                  else
                  {
                      u8Value = u8Value & ( ~ucBitPos );
                  }
                  msSWDBWriteByte( wReg, u8Value );
              }
              #endif
 271          
 272          
 273          #define DELAY1US()  _nop_()
 274          //DIRECT_BUS
 275          /////////////////////////////////////////////////////////////////////////
 276          BYTE msReadByte( DWORD u32Reg )
 277          {
 278   1          DWORD ucdata = 0;
 279   1      
 280   1          if((g_bCorePowerStatus==0) && ((u32Reg&0x00FF0000)))
 281   1          {
 282   2              DB_DEBUG_printMsg("Error >> Illegal NonPM Domain Access !!!!!");
 283   2              return 0;
 284   2          }
 285   1      
 286   1          P2 = (u32Reg & 0x00FF0000)>>16; // Bank switch for 51 (P2 need bk in ISR)
 287   1          if( u32Reg & 0x80000000 ) // Sub bank
 288   1          {
 289   2              msRegs[u32Reg & 0x0000FF00] = ( u32Reg >> 24 ) & 0x7F;
 290   2          }
 291   1          ucdata = msRegs[u32Reg & 0x0000FFFF];
 292   1          P2 = 0; // added for 51 switch code bank via xfr, need move to .a51??
 293   1          return ucdata;
 294   1      
 295   1      }
 296          void msWriteByte( DWORD u32Reg, BYTE u8Val )
 297          {
 298   1          if((g_bCorePowerStatus==0) && ((u32Reg&0x00FF0000)))
 299   1          {
 300   2              DB_DEBUG_printMsg("Error >> Illegal NonPM Domain Access !!!!!");
 301   2              return;
C51 COMPILER V9.00   MS_RWREG                                                              07/03/2017 18:41:19 PAGE 6   

 302   2          }
 303   1      
 304   1          P2 = (u32Reg & 0x00FF0000)>>16; // Bank switch for 51 (P2 need bk in ISR)
 305   1          if( u32Reg & 0x80000000 ) // Sub bank
 306   1          {
 307   2              msRegs[u32Reg & 0x0000FF00] = ( u32Reg >> 24 ) & 0x7F;
 308   2              msRegs[u32Reg & 0x0000FFFF] = u8Val;
 309   2          }
 310   1          else
 311   1              msRegs[u32Reg & 0x0000FFFF] = u8Val;
 312   1          P2 = 0; // added for 51 switch code bank via xfr, need move to .a51??
 313   1      }
 314          
 315          void msWriteBit( DWORD u32Reg, Bool bBit, BYTE u8BitPos )
 316          {
 317   1          BYTE u8Value;
 318   1      
 319   1          ReqstRIU();
 320   1          u8Value = msReadByte( u32Reg );
 321   1          if( bBit )
 322   1          {
 323   2              u8Value = u8Value | (u8BitPos);
 324   2          }
 325   1          else
 326   1          {
 327   2              u8Value = u8Value & ( ~u8BitPos );
 328   2          }
 329   1          msWriteByte( u32Reg, u8Value );
 330   1          RelesRIU();
 331   1      }
 332          
 333          //Jison:110428 change msRead2Byte() u16Reg to low addr.
 334          WORD msRead2Byte( DWORD u32RegLoAddr )
 335          {
 336   1          return ((( WORD )msReadByte( u32RegLoAddr+1 ) ) << 8 ) | msReadByte( u32RegLoAddr );
 337   1      }
 338          
 339          
 340          #if 0
              BYTE scReadByte( BYTE u8Reg )
              {
                  return scRegs[u8Reg];
              }
              
              void scWriteByte( BYTE u8Reg, BYTE u8Value )
              {
                  scRegs[u8Reg] = u8Value;
              }
              #endif
 351          
 352          //Jison:110428 u16Reg is low addr.
 353          void msWrite2Byte( DWORD u32RegLoAddr, WORD u16Value )
 354          {
 355   1          msWriteByte( u32RegLoAddr, ( BYTE )u16Value );
 356   1          msWriteByte( u32RegLoAddr + 1, ( BYTE )( u16Value >> 8 ) );
 357   1      }
 358          void msWriteByteMask( DWORD u32Reg, BYTE u8Value, BYTE u8Mask )
 359          {
 360   1          ReqstRIU();
 361   1          msWriteByte( u32Reg, ( (msReadByte( u32Reg ) & ( ~u8Mask )) | ( (u8Value) & (u8Mask) ) ) );
 362   1          RelesRIU();
 363   1      }
C51 COMPILER V9.00   MS_RWREG                                                              07/03/2017 18:41:19 PAGE 7   

 364          
 365          //Jison:110428 u16Reg is low addr.
 366          void msWrite2ByteMask( DWORD u32RegLoAddr, WORD u16Value , WORD u16Mask )
 367          {
 368   1          msWriteByteMask( u32RegLoAddr, ( BYTE )u16Value, ( BYTE ) u16Mask );
 369   1          msWriteByteMask( u32RegLoAddr + 1, ( BYTE )( u16Value >> 8 ), ( BYTE )( u16Mask >> 8 ) );
 370   1      }
 371          
 372          void msWrite3Byte( DWORD u32RegLoAddr, DWORD u32Value )
 373          {
 374   1          msWriteByte( u32RegLoAddr, ( BYTE )u32Value );
 375   1          msWriteByte( u32RegLoAddr + 1, ( BYTE )( u32Value >> 8 ) );
 376   1          msWriteByte( u32RegLoAddr + 2, ( BYTE )( u32Value >> 16 ) );
 377   1      }
 378          
 379          void msWrite4Byte( DWORD u32RegLoAddr, DWORD u32Value )
 380          {
 381   1          msWriteByte( u32RegLoAddr, ( BYTE )u32Value );
 382   1          msWriteByte( u32RegLoAddr + 1, ( BYTE )( u32Value >> 8 ) );
 383   1          msWriteByte( u32RegLoAddr + 2, ( BYTE )( u32Value >> 16 ) );
 384   1          msWriteByte( u32RegLoAddr + 3, ( BYTE )( u32Value >> 24 ) );
 385   1      }
 386          
 387          
 388          BYTE MEM_MSREAD_BYTE( DWORD u32Reg )  // Need Change Sub Bank Manually if necessary, for performanace cons
             -ideration in ISR !!!!
 389          {
 390   1          BYTE u8Value;
 391   1          P2 = (u32Reg & 0x00FF0000)>>16; // Bank switch for 51 (P2 need bk in ISR)
 392   1      #if 1 // Need Change Sub Bank Manually if necessary, for performanace consideration in ISR !!!!
 393   1          u8Value = msRegs[u32Reg & 0x0000FFFF];
 394   1          P2 = 0; // added for 51 switch code bank via xfr, need move to .a51??
 395   1          return u8Value;
 396   1      #else
                  if( u32Reg & 0x80000000 ) // Sub bank
                  {
                      msRegs[u32Reg & 0x0000FF00] = ( u32Reg >> 24 ) & 0x7F;
                  }
                  u8Value = msRegs[u32Reg & 0x0000FFFF];
                  P2 = 0; // added for 51 switch code bank via xfr, need move to .a51??
                  return u8Value;
              #endif
 405   1      }
 406          BYTE MEM_MSREAD_BYTE_EXT0(DWORD u32Reg)
 407          {
 408   1          BYTE u8Value;
 409   1          P2 = (u32Reg & 0x00FF0000)>>16; // Bank switch for 51 (P2 need bk in ISR)
 410   1          u8Value = msRegs[u32Reg & 0x0000FFFF];
 411   1          P2 = 0; // added for 51 switch code bank via xfr, need move to .a51??
 412   1          return u8Value;
 413   1      }
 414          BYTE MEM_MSREAD_BYTE_EXT1(DWORD u32Reg)
 415          {
 416   1          BYTE u8Value;
 417   1          P2 = (u32Reg & 0x00FF0000)>>16; // Bank switch for 51 (P2 need bk in ISR)
 418   1          u8Value = msRegs[u32Reg & 0x0000FFFF];
 419   1          P2 = 0; // added for 51 switch code bank via xfr, need move to .a51??
 420   1          return u8Value;
 421   1      }
 422          
 423          #if _NEW_SOG_WAKEUP_DET_
              BYTE MEM_MSREAD_BYTE_TIME0(DWORD u32Reg)
C51 COMPILER V9.00   MS_RWREG                                                              07/03/2017 18:41:19 PAGE 8   

              {
                  BYTE u8Value;
                  P2 = (u32Reg & 0x00FF0000)>>16; // Bank switch for 51 (P2 need bk in ISR)
                  u8Value = msRegs[u32Reg & 0x0000FFFF];
                  P2 = 0; // added for 51 switch code bank via xfr, need move to .a51??
                  return u8Value;
              }
              #endif
 433          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    900    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----      71
   IDATA SIZE       =      2       4
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
