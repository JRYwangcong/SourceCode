

#include "GPIO_DEF.h"
#include "Ms_rwreg.h"

#if ENABLE_5707

#define ENDTBL_FLAG 	(0xff)
#define MAX_AMP_REG_LEN (20)

#if (defined(KTC_Project))
#define TAS5707_MAX_VOL (0x00)
#define TAS5707_MID_VOL (0x00)
#define TAS5707_MIN_VOL (0xff) //Mute
#else
#define TAS5707_MAX_VOL (0x07)
#define TAS5707_MID_VOL (0x20)
#define TAS5707_MIN_VOL (0xff) //Mute
#endif

#define TAS5707_INIT_INTERVAL (100) //Delay 65ms
#define  A5707  0x36
#define  A5707A  0x3a
#define  A5707_DEVICE  A5707

//#define hw_SetAudioReset()                {   (MEM_MSWRITE_BIT(_REG_GPIO4_OEZ, FALSE, BIT3)) ;(MEM_MSWRITE_BIT(_REG_GPIO4_OUT, TRUE, BIT3));}//  (MEM_MSWRITE_BIT(_REG_GPIOAU_OUT, FALSE, BIT0))
//#define hw_ClrAudioReset()           {(MEM_MSWRITE_BIT(_REG_GPIO4_OEZ, FALSE, BIT3));(MEM_MSWRITE_BIT(_REG_GPIO4_OUT, FALSE, BIT3));}//         (MEM_MSWRITE_BIT(_REG_GPIOAU_OUT, TRUE, BIT0))


#define i2cSlaveAddr(deviceID, addr)    (deviceID|((addr>>8)<<1))
#define i2cWordAddr(addr)       (addr&0xFF)

extern void i2c_WriteTBL( BYTE deviceID, WORD addr, BYTE *buffer, BYTE count );
extern void i2c_ReadTBL( BYTE deviceID, WORD addr, BYTE *buffer, BYTE count );
extern Bool i2c_Start( void );
extern void i2c_Stop( void );
extern Bool Wait_i2C_Ack( void );
extern Bool i2c_SendByte( BYTE value );
extern BYTE i2c_ReceiveByte( const Bool ack );
extern void i2c_Start1(void);
extern void i2C_Intial(void);
extern Bool i2c_BurstWrite( BYTE count, BYTE *buffer );
extern Bool i2c_BurstRead( BYTE count, BYTE * buffer );
extern Bool i2c_MasterStart( I2C_Direction direct, BYTE addr );
extern Bool i2c_jry_Start( I2C_Direction direct, BYTE addr );



#define A5707_DEBUG   0
#if ENABLE_MSTV_UART_DEBUG&&A5707_DEBUG
    #define A5707_PRINT(format, ...)     printf(format, ##__VA_ARGS__)
#else
    #define A5707_PRINT(format, ...)`
#endif



typedef struct
{
    BYTE bAddr;
    BYTE bLength;
    BYTE bArray[MAX_AMP_REG_LEN];
}TAS5707_REGMAP;

static TAS5707_REGMAP Tas5707_DefautTbl[] = //Skyworth name: DrvTas5711InitTbl1_8K10_U1
{
  ///  {0x00,0x01,{0x64}},					//0:factory trim
    {0x1B,0x01,{0x00}},					//0:factory trim
   // {0x04,0x01,{0x04}},					//0:soft mute
    {0x06,0x01,{0x00}},					//0:soft mute
    {0x20,0x04,{0x00,0x89,0x77,0x72}},	//0x98->0x89 to invert L/R output, BD Mode
    {0x11,0x01,{0xB8}},					//0xB8:BD Mode
    {0x12,0x01,{0x60}},					//0x60:BD Mode
    {0x13,0x01,{0xB8}},					//0xA0:BD Mode
    {0x14,0x01,{0x60}},					//0x48:BD Mode
    {0x50,0x04,{0x00,0x00,0x00,0x80}},	//Band switch and EQ Control

#if 0
	//Channel L 7Band EQ Params
    {0x29,0x14,{0x00,0x7D,0xE2,0x80,0x0F,0x04,0x3B,0x00,0x00,0x7D,0xE2,0x80,0x00,0xFB,0xBC,0x0E,0x0F,0x84,0x32,0x0E}}, 
    {0x2A,0x14,{0x00,0x80,0x62,0xCF,0x0F,0x01,0xF1,0x17,0x00,0x7D,0xBE,0x29,0x00,0xFE,0x0E,0xE9,0x0F,0x81,0xDF,0x08}}, 
    {0x2B,0x14,{0x00,0x7F,0x0A,0x34,0x0F,0x05,0x77,0x70,0x00,0x7B,0xC1,0xBA,0x00,0xFA,0x88,0x90,0x0F,0x85,0x34,0x11}}, 
    {0x2C,0x14,{0x00,0x81,0x7B,0xF2,0x0F,0x2F,0xEF,0x50,0x00,0x6E,0xC4,0xD0,0x00,0xD0,0x10,0xB0,0x0F,0x8F,0xBF,0x3D}}, 
    {0x2D,0x14,{0x00,0x83,0x3C,0x34,0x0F,0x44,0x4A,0xED,0x00,0x69,0x5D,0x5F,0x00,0xBB,0xB5,0x13,0x0F,0x93,0x66,0x6D}}, 
    {0x2E,0x14,{0x00,0x86,0x24,0xA3,0x0F,0x8E,0xE4,0x1E,0x00,0x5C,0x13,0x21,0x00,0x71,0x1B,0xE2,0x0F,0x9D,0xC8,0x3B}}, 
    {0x2F,0x14,{0x00,0x8B,0x28,0xB2,0x00,0x00,0x00,0x00,0x00,0x3E,0xBD,0xEA,0x00,0x00,0x00,0x00,0x0F,0xB6,0x19,0x63}}, 
    //Channel R 7Band EQ Params                                                                                                                    
    {0x30,0x14,{0x00,0x7D,0xE2,0x80,0x0F,0x04,0x3B,0x00,0x00,0x7D,0xE2,0x80,0x00,0xFB,0xBC,0x0E,0x0F,0x84,0x32,0x0E}}, 
    {0x31,0x14,{0x00,0x80,0x62,0xCF,0x0F,0x01,0xF1,0x17,0x00,0x7D,0xBE,0x29,0x00,0xFE,0x0E,0xE9,0x0F,0x81,0xDF,0x08}}, 
    {0x32,0x14,{0x00,0x7F,0x0A,0x34,0x0F,0x05,0x77,0x70,0x00,0x7B,0xC1,0xBA,0x00,0xFA,0x88,0x90,0x0F,0x85,0x34,0x11}}, 
    {0x33,0x14,{0x00,0x81,0x7B,0xF2,0x0F,0x2F,0xEF,0x50,0x00,0x6E,0xC4,0xD0,0x00,0xD0,0x10,0xB0,0x0F,0x8F,0xBF,0x3D}}, 
    {0x34,0x14,{0x00,0x83,0x3C,0x34,0x0F,0x44,0x4A,0xED,0x00,0x69,0x5D,0x5F,0x00,0xBB,0xB5,0x13,0x0F,0x93,0x66,0x6D}}, 
    {0x35,0x14,{0x00,0x86,0x24,0xA3,0x0F,0x8E,0xE4,0x1E,0x00,0x5C,0x13,0x21,0x00,0x71,0x1B,0xE2,0x0F,0x9D,0xC8,0x3B}}, 
    {0x36,0x14,{0x00,0x8B,0x28,0xB2,0x00,0x00,0x00,0x00,0x00,0x3E,0xBD,0xEA,0x00,0x00,0x00,0x00,0x0F,0xB6,0x19,0x63}}, 
#else


    {0x29,0x14,{0x00,0x7F,0x55,0x51,0x0F,0x80,0xAA,0xAF,0x00,0x00,0x00,0x00,0x00,0x7E,0xAA,0xA3,0x00,0x00,0x00,0x00}},
    {0x2A,0x14,{0x00,0x7F,0x83,0xD8,0x0F,0x02,0xD2,0xDA,0x00,0x7D,0xDB,0x4F,0x00,0xFD,0x2D,0x26,0x0F,0x82,0xA0,0xD8}},
    {0x2B,0x14,{0x00,0x80,0x7C,0xA0,0x0F,0x02,0x35,0x8E,0x00,0x7D,0xD9,0x39,0x00,0xFD,0xCA,0x72,0x0F,0x81,0xAA,0x27}},
    {0x2C,0x14,{0x00,0x81,0xA3,0xAE,0x0F,0x08,0xB0,0x42,0x00,0x78,0xC1,0x41,0x00,0xF7,0x4F,0xBE,0x0F,0x85,0x9B,0x11}},
    {0x2D,0x14,{0x00,0x85,0x2A,0x32,0x0F,0x2E,0x41,0x33,0x00,0x61,0xCB,0xB8,0x00,0xD1,0xBE,0xCD,0x0F,0x99,0x0A,0x15}},
    {0x2E,0x14,{0x00,0x8B,0xBA,0xC9,0x0F,0xA7,0xEC,0xDA,0x00,0x3B,0x67,0x91,0x00,0x58,0x13,0x26,0x0F,0xB8,0xDD,0xA6}},
    {0x2F,0x14,{0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
    {0x30,0x14,{0x00,0x7F,0x55,0x51,0x0F,0x80,0xAA,0xAF,0x00,0x00,0x00,0x00,0x00,0x7E,0xAA,0xA3,0x00,0x00,0x00,0x00}},
    {0x31,0x14,{0x00,0x7F,0x83,0xD8,0x0F,0x02,0xD2,0xDA,0x00,0x7D,0xDB,0x4F,0x00,0xFD,0x2D,0x26,0x0F,0x82,0xA0,0xD8}},
    {0x32,0x14,{0x00,0x80,0x7C,0xA0,0x0F,0x02,0x35,0x8E,0x00,0x7D,0xD9,0x39,0x00,0xFD,0xCA,0x72,0x0F,0x81,0xAA,0x27}},
    {0x33,0x14,{0x00,0x81,0xA3,0xAE,0x0F,0x08,0xB0,0x42,0x00,0x78,0xC1,0x41,0x00,0xF7,0x4F,0xBE,0x0F,0x85,0x9B,0x11}},
    {0x34,0x14,{0x00,0x85,0x2A,0x32,0x0F,0x2E,0x41,0x33,0x00,0x61,0xCB,0xB8,0x00,0xD1,0xBE,0xCD,0x0F,0x99,0x0A,0x15}},
    {0x35,0x14,{0x00,0x8B,0xBA,0xC9,0x0F,0xA7,0xEC,0xDA,0x00,0x3B,0x67,0x91,0x00,0x58,0x13,0x26,0x0F,0xB8,0xDD,0xA6}},
    {0x36,0x14,{0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}},
    
#endif

	//Energy Filter Params(a,w)
	{0x3A,0x08,{0x00,0x00,0x94,0x43,0x00,0x7F,0x6B,0xB9}},
	//Attack and Decay filters
	{0x3B,0x08,{0x00,0x00,0x4A,0x37,0x00,0x7F,0xB5,0xC5}},
	{0x3C,0x08,{0x00,0x00,0x4A,0x37,0x00,0x7F,0xB5,0xC5}},

	//Compression Control(T,K,O)
	{0x40,0x04,{0xFD,0x31,0x66,0x89}},
	{0x41,0x04,{0x0F,0x82,0xD8,0x2E}},
	{0x42,0x04,{0x00,0x09,0x44,0x04}}, 

	{0x46,0x04,{0x00,0x00,0x00,0x01}},	   //DRC Control 

	//{0x50,0x04,{0x00,0x00,0x00,0x82}},	//Band switch and EQ Control

	{0x07,0x01,{TAS5707_MID_VOL}},					//default umute,mute:0xff,umute:0x5
	{0x05,0x01,{0x00}},					//0: start play, 1:power down and hard mute

	{ENDTBL_FLAG ,0x01,{0x00}},
};

 WORD A5707WriteReg(BYTE u1Addr, BYTE *pu1Buf, WORD u2ByteCnt)
{
WORD s16Ret = true;
BYTE deviceID=A5707_DEVICE;
WORD addr=u1Addr;
BYTE *buffer;
buffer=pu1Buf;
BYTE count =u2ByteCnt;
BYTE slaveAddr = i2cSlaveAddr( deviceID, (addr) );
BYTE wordAddr = i2cWordAddr( addr );
WORD retry = 5;

while( retry-- )
		{
		if( i2c_jry_Start( I2C_WRITE, slaveAddr ) == FALSE )
		continue;
		if( i2c_BurstWrite( 1, &wordAddr ) == FALSE )
		continue;
		if( i2c_BurstWrite( count, ( buffer ) ) == FALSE )
		continue;
		i2c_Stop();
		}
	

if (retry)
s16Ret=TRUE;
	else
s16Ret=FALSE	;	

    return s16Ret;
}

 WORD A5707ReadReg(BYTE u1Addr, BYTE *pu1Buf, WORD u2ByteCnt)
{
WORD s16Ret = true;
BYTE deviceID  =A5707_DEVICE;
WORD addr=u1Addr;
BYTE *buffer;
buffer=pu1Buf;
BYTE count =u2ByteCnt;
BYTE slaveAddr = i2cSlaveAddr( deviceID, addr );
BYTE wordAddr = i2cWordAddr( addr );
WORD retry = 5;

    while( retry-- )
    {
        if( i2c_jry_Start( I2C_WRITE, slaveAddr ) == FALSE )
            continue;
        if( i2c_BurstWrite( 1, &wordAddr ) == FALSE )
            continue;
        if( i2c_jry_Start( I2C_READ, slaveAddr ) == FALSE )
            continue;
        if( i2c_BurstRead( count, buffer ) == FALSE )
            continue;
    }

if (retry)
s16Ret=TRUE;
	else
s16Ret=FALSE	;	

    return s16Ret;
}

 void AMPReset(BOOL bReset)
{

	if (bReset)
	{        	
	hw_SetAudioReset() ;
	Delay1ms(TAS5707_INIT_INTERVAL);

	}
	else
	{
	hw_ClrAudioReset();
	Delay1ms(20);
	}

	return;
}

 void AMPHWMute(BOOL bMute)
{
	Delay1ms(1);
	

		if (bMute)
		{        	
		hw_SetAudio_SD() ;
		}
		else
		{
		hw_ClrAudio_SD();
		}
	return;
}

/*Ref from Skyworth*/
  WORD AMP_Init(void)
{
	WORD 			s16Ret = 0;
	BYTE 			u8Index, u8Addr, u8Length, u8CountLoop;
	BYTE 			u8Array[MAX_AMP_REG_LEN];
	TAS5707_REGMAP 	*pstTas5707InitTbl;
#if A5707_DEBUG
	BYTE readArray[MAX_AMP_REG_LEN]	=	{0};
#endif
	pstTas5707InitTbl 	= Tas5707_DefautTbl;

	AMPHWMute(false);
	Delay1ms(10);
	AMPReset(true);		//gmh add 20140423
	Delay1ms(10);
	//Release Reset AMP
	AMPReset(false);		
	//ForceDelay1ms(14);

	for(u8Index = 0; ; u8Index ++)
	{
		u8Addr = pstTas5707InitTbl[u8Index].bAddr;
		if(u8Addr == ENDTBL_FLAG)
		{
			break;
		}

		u8Length = pstTas5707InitTbl[u8Index].bLength;
		for(u8CountLoop = 0; u8CountLoop < u8Length; u8CountLoop ++)
		{		
		u8Array[u8CountLoop] = *(pstTas5707InitTbl[u8Index].bArray + u8CountLoop);
		}
		s16Ret =A5707WriteReg(u8Addr, u8Array, u8Length);

		#if A5707_DEBUG

		A5707_PRINT("W   addr:0x%x, length:0x%x, ",	u8Addr,	u8Length);
		for(u8CountLoop = 0;	u8CountLoop < u8Length;	u8CountLoop ++)
		{
			A5707_PRINT("0x%x,",	u8Array[u8CountLoop]);
		}	
				A5707_PRINT("\n");

		#endif

		if(s16Ret != true)
		{
		;//	A5707_PRINT("TAS5707 Init Fail \n");
		}

		//0x1B:Oscillator Trim, 0x46:DRC Control, 0x50:EQ Control, 0xF9:I2C Device Addr
		if((u8Addr == 0x1B) || (u8Addr == 0x46) || (u8Addr == 0x50) || (u8Addr == 0xF9))
		{	
			Delay1ms(50);
		}

		#if A5707_DEBUG
		//BYTE readArray[MAX_AMP_REG_LEN]	=	{0};
		s16Ret = A5707ReadReg(u8Addr, readArray, u8Length);
		A5707_PRINT("R   addr:0x%x, length:0x%x, ",	u8Addr,	u8Length);
		for(u8CountLoop = 0;	u8CountLoop < u8Length;	u8CountLoop ++)
		{
			A5707_PRINT("0x%x,",	readArray[u8CountLoop]);
		}	
		A5707_PRINT("\n");
		#endif

	}

		#if A5707_DEBUG
		for (u8Addr=0;u8Addr<0x1f;u8Addr++)
			{
			u8Length=1;
			s16Ret = A5707ReadReg(u8Addr, readArray, u8Length);
			A5707_PRINT("R   addr:0x%x, length:0x%x, ",	u8Addr,	u8Length);
			for(u8CountLoop = 0;	u8CountLoop < u8Length;	u8CountLoop ++)
			{
				A5707_PRINT("0x%x,",	readArray[u8CountLoop]);
			}	
			A5707_PRINT("\n");
			}
		#endif


       // AMP_SetSubWooferVol(90);


	return TRUE;
}

 WORD AMP_DeInit(VOID)
{
	AMPReset(TRUE);	
    return  TRUE;
}

 WORD AMP_SetMute(BOOL bMute)
{
	WORD s16Ret;
	BYTE  u8Gain[1]= {0};

	if (bMute)
	{
		u8Gain[0] = TAS5707_MIN_VOL;
		s16Ret = A5707WriteReg(0x07, u8Gain, 1);
	}
	else
	{
		u8Gain[0] = TAS5707_MID_VOL;
		s16Ret = A5707WriteReg(0x07, u8Gain, 1);
	}
	return s16Ret;
}

  WORD AMP_GetMute(BOOL* pbMute)
{
	WORD s16Ret;
	BYTE  u8Gain = 0;
	
	s16Ret = A5707ReadReg(0x07, &u8Gain, 1);
	if (u8Gain == TAS5707_MIN_VOL)
	{
		*pbMute = TRUE;
	}
	else
	{
		*pbMute = FALSE;
	}
    return s16Ret; 
}

  WORD AMP_SetSubWooferVol(BYTE u32Volume)
{
	WORD s16Ret;
	BYTE  u8Gain[1]= {0};
	if (u32Volume==0)
		u8Gain[0] =0xff;//(TAS5707_MIN_VOL-((TAS5707_MIN_VOL-TAS5707_MAX_VOL)/u32Volume));
		else
		u8Gain[0] =(TAS5707_MIN_VOL-(BYTE)(((TAS5707_MIN_VOL-TAS5707_MAX_VOL)*u32Volume)/100));


		s16Ret = A5707WriteReg(0x07, u8Gain, 1);
	#if A5707_DEBUG
		s16Ret = A5707ReadReg(0x07, u8Gain, 1);
		A5707_PRINT("AMP_SetSubWooferVol :0x%x,",u8Gain[0]);
	#endif

    return TRUE; 
}


  WORD AMP_WriteReg(WORD u32RegAddr, WORD u32ByteSize, BYTE* pu8Value)
{
    WORD Ret;
	WORD i;
	BYTE  RegArray[MAX_AMP_REG_LEN];

	if (u32ByteSize > MAX_AMP_REG_LEN)
	{
	//	A5707_PRINT("TAS5707 reg length MAX is 20\n");
		u32ByteSize = MAX_AMP_REG_LEN;
	}

	for(i=0; i<u32ByteSize;i++)
	{

	RegArray[i]=*pu8Value;
	pu8Value++;
	}
	
	Ret = A5707WriteReg(u32RegAddr, RegArray, u32ByteSize);
    if(Ret != TRUE)
	{
		;//A5707_PRINT("TAS5707 write I2C Fail \n");
	}
    
    return TRUE; 
}

  WORD AMP_ReadReg(WORD u32RegAddr, WORD u32ByteSize, BYTE* pu8Value)
{
    WORD Ret;
	WORD i;
	BYTE  RegArray[MAX_AMP_REG_LEN];

	if (u32ByteSize > MAX_AMP_REG_LEN)
	{
		;//A5707_PRINT("TAS5707 reg length MAX is 20\n");
		u32ByteSize = MAX_AMP_REG_LEN;
	}
	
	Ret = A5707ReadReg(u32RegAddr, RegArray, u32ByteSize);
    if(Ret != TRUE)
	{
		;//A5707_PRINT("TAS5707 Read I2C Fail \n");
	}


	for( i=0; i<u32ByteSize;i++)
	{

	*pu8Value=RegArray[i];
	pu8Value++;
	}
	
    return TRUE; 
}


#endif


